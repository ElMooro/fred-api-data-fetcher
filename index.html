import React, { useState, useEffect, useCallback } from 'react';
import {
  LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend,
  ResponsiveContainer, ReferenceLine, ReferenceArea, Label
} from 'recharts';
import * as math from 'mathjs';
// import _ from 'lodash'; // Removed: Unused import

// Financial Crisis Events
const FINANCIAL_CRISES = [
  { name: "Black Monday", date: "1987-10-19", description: "Stock market crash where Dow Jones fell by 22.6%" },
  { name: "Dot-com Bubble", startDate: "2000-03-10", endDate: "2002-10-09", description: "Tech stock bubble burst" },
  { name: "Global Financial Crisis", startDate: "2007-12-01", endDate: "2009-06-01", description: "Subprime mortgage crisis" },
  { name: "Flash Crash", date: "2010-05-06", description: "Brief stock market crash with trillion-dollar losses" },
  { name: "European Debt Crisis", startDate: "2010-04-01", endDate: "2012-07-26", description: "Sovereign debt crisis in Europe" },
  { name: "COVID-19 Crash", date: "2020-03-16", description: "Pandemic-induced market crash" }
];

// Data sources
const DATA_SOURCES = {
  FRED: [
    { id: "GDP", name: "Gross Domestic Product", frequency: "quarterly" },
    { id: "UNRATE", name: "Unemployment Rate", frequency: "monthly" },
    { id: "FEDFUNDS", name: "Federal Funds Rate", frequency: "monthly" }
  ],
  ECB: [
    { id: "EXR.D.USD.EUR.SP00.A", name: "USD/EUR Exchange Rate", frequency: "daily" },
    { id: "MFI.M.U2.Y.V.M30.X.I.U2.2300.Z01.A", name: "Eurozone M3 Money Supply", frequency: "monthly" }
  ],
  NYFED: [
    { id: "SOFR", name: "Secured Overnight Financing Rate", frequency: "daily" }
  ],
  OFR: [
    { id: "FSI", name: "Financial Stress Index", frequency: "daily" }
  ]
};

// Transformations
const TRANSFORMATIONS = [
  { id: "raw", name: "Raw Data (No Transformation)" },
  { id: "mom", name: "Month-over-Month Change" },
  { id: "mom_pct", name: "Month-over-Month % Change" },
  { id: "qoq", name: "Quarter-over-Quarter Change" },
  { id: "qoq_pct", name: "Quarter-over-Quarter % Change" },
  { id: "yoy", name: "Year-over-Year % Change" } // Commonly Year-over-Year % Change
];

// Time frames
const TIME_FRAMES = [
  { id: "daily", name: "Daily" },
  { id: "weekly", name: "Weekly" },
  { id: "monthly", name: "Monthly" },
  { id: "quarterly", name: "Quarterly" },
  { id: "semiannual", name: "Half-Yearly" },
  { id: "annual", name: "Yearly" }
];

// Mock data generator
const generateMockData = (seriesId, frequency, startDate, endDate) => {
  const data = [];
  let currentDate = new Date(startDate);
  const end = new Date(endDate);

  let value = 100; // Base value

  while (currentDate <= end) {
    value = value * (1 + (Math.random() * 0.06 - 0.03)); // Add some randomness

    data.push({
      date: currentDate.toISOString().split('T')[0],
      value: parseFloat(value.toFixed(2))
    });

    // Move to next period
    if (frequency === 'daily') {
      currentDate.setDate(currentDate.getDate() + 1);
    } else if (frequency === 'weekly') {
      currentDate.setDate(currentDate.getDate() + 7);
    } else if (frequency === 'monthly') {
      currentDate.setMonth(currentDate.getMonth() + 1);
    } else if (frequency === 'quarterly') {
      currentDate.setMonth(currentDate.getMonth() + 3);
    } else if (frequency === 'semiannual') {
      currentDate.setMonth(currentDate.getMonth() + 6);
    } else if (frequency === 'annual') {
      currentDate.setFullYear(currentDate.getFullYear() + 1);
    } else { // Default to monthly if frequency is unknown, or handle error
        currentDate.setMonth(currentDate.getMonth() + 1);
    }
  }
  return data;
};

// Dashboard component
const Dashboard = () => {
  // State
  const [selectedSource, setSelectedSource] = useState('FRED');
  const [selectedIndicator, setSelectedIndicator] = useState('UNRATE');
  const [selectedTimeFrame, setSelectedTimeFrame] = useState('monthly'); // Note: This state is selected but not used to resample data
  const [selectedTransformation, setSelectedTransformation] = useState('raw');
  const [rawData, setRawData] = useState([]); // Store raw data
  const [chartData, setChartData] = useState([]); // Data to be displayed (potentially transformed)
  const [startDate, setStartDate] = useState('2000-01-01');
  const [endDate, setEndDate] = useState('2025-04-30');
  const [isLoading, setIsLoading] = useState(false);
  const [watchlist, setWatchlist] = useState([]);
  const [selectedTab, setSelectedTab] = useState('explore');
  const [connectionStatus, setConnectionStatus] = useState('Disconnected');

  const getIndicatorDetails = useCallback(() => {
    const sourceData = DATA_SOURCES[selectedSource] || [];
    return sourceData.find(item => item.id === selectedIndicator) || {};
  }, [selectedSource, selectedIndicator]);

  const fetchData = useCallback(() => {
    setIsLoading(true);
    const indicatorDetails = getIndicatorDetails();

    // Simulate API delay
    setTimeout(() => {
      const data = generateMockData(
        selectedIndicator,
        indicatorDetails.frequency || 'monthly', // Use indicator's native frequency
        startDate,
        endDate
      );
      setRawData(data); // Store the fetched raw data
      // At this point, chartData will be updated by the transformation useEffect
      setIsLoading(false);
    }, 500);
  }, [selectedIndicator, getIndicatorDetails, startDate, endDate]); // Added getIndicatorDetails

  // Initial data load
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Effect to apply transformations when rawData or selectedTransformation changes
  useEffect(() => {
    if (rawData.length === 0) {
      setChartData([]);
      return;
    }

    // Placeholder for actual transformation logic
    // For now, just passes raw data or could be extended
    let transformed = [...rawData]; // Make a copy to avoid mutating rawData

    // TODO: Implement actual transformation logic based on selectedTransformation
    // Example (very basic, needs proper date handling for MoM, YoY etc.):
    if (selectedTransformation === 'mom' && transformed.length > 1) {
      // This is a conceptual placeholder, real MoM needs date logic
      // transformed = transformed.map((d, i, arr) => ({
      //   ...d,
      //   value: i > 0 ? d.value - arr[i-1].value : 0 // Simplified, not robust
      // }));
      console.log("Month-over-Month transformation selected - logic not fully implemented yet.");
    } else if (selectedTransformation === 'yoy' && transformed.length > 0) {
      // This is a conceptual placeholder, real YoY needs date logic & matching to prev year
      console.log("Year-over-Year transformation selected - logic not fully implemented yet.");
    }
    // ... other transformations

    setChartData(transformed);
  }, [rawData, selectedTransformation]);


  const addToWatchlist = () => {
    const details = getIndicatorDetails();
    const newItem = {
      id: `${selectedSource}-${selectedIndicator}-${Date.now()}`,
      source: selectedSource,
      indicator: selectedIndicator,
      name: details.name || selectedIndicator,
      // Store current date range for consistency, or make it dynamic
      startDate,
      endDate,
      frequency: details.frequency || 'monthly'
    };
    setWatchlist(prev => [...prev, newItem]);
  };

  const removeFromWatchlist = (id) => {
    setWatchlist(prev => prev.filter(item => item.id !== id));
  };

  const connectWebSocket = () => {
    setConnectionStatus('Connecting...');
    setTimeout(() => setConnectionStatus('Connected'), 1000);
  };

  const disconnectWebSocket = () => {
    setConnectionStatus('Disconnected');
  };

  // Memoize watchlist item data to prevent re-generation on every render unless dependencies change
  const WatchlistItemChart = React.memo(({ item }) => {
    const [itemData, setItemData] = useState([]);

    useEffect(() => {
        // Generate data once when item props change
        const data = generateMockData(
            item.indicator,
            item.frequency,
            item.startDate, // Use item specific start/end or global ones
            item.endDate
        );
        setItemData(data);
    }, [item.indicator, item.frequency, item.startDate, item.endDate]);


    if (!itemData.length) return <div className="h-48 flex items-center justify-center"><p className="text-gray-400 text-xs">Loading data...</p></div>;

    return (
        <div className="h-48">
            <ResponsiveContainer width="100%" height="100%">
                <LineChart
                    data={itemData}
                    margin={{ top: 5, right: 20, left: -20, bottom: 5 }} // Adjust margins for mini chart
                >
                    <XAxis dataKey="date" tick={{ fontSize: 10 }} interval="preserveStartEnd" tickFormatter={(tick) => new Date(tick).getFullYear()} />
                    <YAxis tick={{ fontSize: 10 }} domain={['auto', 'auto']} />
                    <Tooltip contentStyle={{ fontSize: '10px' }} />
                    <Line type="monotone" dataKey="value" stroke="#3B82F6" dot={false} strokeWidth={1.5}/>
                </LineChart>
            </ResponsiveContainer>
        </div>
    );
});


  return (
    <div className="min-h-screen bg-gray-100 p-4">
      <div className="max-w-6xl mx-auto">
        <h1 className="text-3xl font-bold text-gray-800 mb-6">Financial Data Dashboard</h1>

        {/* Tabs */}
        <div className="mb-6">
          <div className="border-b border-gray-200">
            <nav className="flex -mb-px">
              <button
                onClick={() => setSelectedTab('explore')}
                className={`mr-4 py-2 px-4 font-medium text-sm ${
                  selectedTab === 'explore'
                    ? 'border-b-2 border-blue-500 text-blue-600'
                    : 'text-gray-600 hover:text-gray-800'
                }`}
              >
                Explore Data
              </button>
              <button
                onClick={() => setSelectedTab('watchlist')}
                className={`mr-4 py-2 px-4 font-medium text-sm ${
                  selectedTab === 'watchlist'
                    ? 'border-b-2 border-blue-500 text-blue-600'
                    : 'text-gray-600 hover:text-gray-800'
                }`}
              >
                Watchlist ({watchlist.length})
              </button>
              <button
                onClick={() => setSelectedTab('live')}
                className={`py-2 px-4 font-medium text-sm ${
                  selectedTab === 'live'
                    ? 'border-b-2 border-blue-500 text-blue-600'
                    : 'text-gray-600 hover:text-gray-800'
                }`}
              >
                Live Data
              </button>
            </nav>
          </div>
        </div>

        {/* Explore Data Tab */}
        {selectedTab === 'explore' && (
          <div className="bg-white shadow rounded-lg p-6">
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
              {/* Data Source */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Data Source</label>
                <select
                  value={selectedSource}
                  onChange={(e) => {
                    setSelectedSource(e.target.value);
                    setSelectedIndicator(DATA_SOURCES[e.target.value][0]?.id || '');
                  }}
                  className="w-full p-2 border rounded bg-white"
                >
                  {Object.keys(DATA_SOURCES).map(source => (
                    <option key={source} value={source}>{source}</option>
                  ))}
                </select>
              </div>

              {/* Indicator */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Indicator</label>
                <select
                  value={selectedIndicator}
                  onChange={(e) => setSelectedIndicator(e.target.value)}
                  className="w-full p-2 border rounded bg-white"
                >
                  {(DATA_SOURCES[selectedSource] || []).map(indicator => (
                    <option key={indicator.id} value={indicator.id}>{indicator.name}</option>
                  ))}
                </select>
              </div>

              {/* Time Frame (Note: this is not used to resample mock data currently) */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Time Frame</label>
                <select
                  value={selectedTimeFrame}
                  onChange={(e) => setSelectedTimeFrame(e.target.value)}
                  className="w-full p-2 border rounded bg-white"
                  disabled // Disabled as it's not used for mock data resampling
                >
                  {TIME_FRAMES.map(frame => (
                    <option key={frame.id} value={frame.id}>{frame.name}</option>
                  ))}
                </select>
                 <p className="text-xs text-gray-400 mt-1">Native frequency used for mock data.</p>
              </div>

              {/* Transformation */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Transformation</label>
                <select
                  value={selectedTransformation}
                  onChange={(e) => setSelectedTransformation(e.target.value)}
                  className="w-full p-2 border rounded bg-white"
                >
                  {TRANSFORMATIONS.map(transform => (
                    <option key={transform.id} value={transform.id}>{transform.name}</option>
                  ))}
                </select>
                 {selectedTransformation !== 'raw' && <p className="text-xs text-orange-500 mt-1">Note: Transformation logic is conceptual.</p>}
              </div>
            </div>

            <div className="flex flex-wrap gap-4 mb-6">
              {/* Date Range */}
              <div className="flex items-center gap-2">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Start Date</label>
                  <input
                    type="date"
                    value={startDate}
                    onChange={(e) => setStartDate(e.target.value)}
                    className="p-2 border rounded bg-white"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">End Date</label>
                  <input
                    type="date"
                    value={endDate}
                    onChange={(e) => setEndDate(e.target.value)}
                    className="p-2 border rounded bg-white"
                  />
                </div>
              </div>

              {/* Action Buttons */}
              <div className="flex items-end gap-2">
                <button
                  onClick={fetchData}
                  className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                  disabled={isLoading}
                >
                  {isLoading ? 'Loading...' : 'Update Chart'}
                </button>

                <button
                  onClick={addToWatchlist}
                  className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
                >
                  Add to Watchlist
                </button>
              </div>
            </div>

            {/* Chart */}
            <div className="h-96 mb-4">
              {isLoading && (
                 <div className="h-full flex items-center justify-center">
                    <p className="text-gray-500">Loading chart data...</p>
                 </div>
              )}
              {!isLoading && chartData.length > 0 ? (
                <ResponsiveContainer width="100%" height="100%">
                  <LineChart
                    data={chartData} // Use potentially transformed data
                    margin={{ top: 20, right: 30, left: 20, bottom: 20 }} // Increased bottom margin for XAxis labels
                  >
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis
                      dataKey="date"
                      tick={{ fontSize: 12 }}
                      angle={-30} // Angle ticks for better readability if dates are many
                      textAnchor="end" // Adjust anchor for angled ticks
                      minTickGap={30} // Show fewer ticks if crowded
                    />
                    <YAxis tick={{ fontSize: 12 }} domain={['auto', 'auto']}/>
                    <Tooltip />
                    <Legend />
                    <Line
                      type="monotone"
                      dataKey="value"
                      name={getIndicatorDetails().name || selectedIndicator}
                      stroke="#3B82F6"
                      strokeWidth={2}
                      dot={{ r: 2 }}
                      activeDot={{ r: 6 }}
                    />

                    {/* Crisis Markers */}
                    {FINANCIAL_CRISES.map(crisis => {
                      // Ensure crisis date is within the chart's visible range for ReferenceLine/Area
                      const crisisStartDate = crisis.date || crisis.startDate;
                      const crisisEndDate = crisis.date || crisis.endDate;
                      
                      if (new Date(crisisStartDate) > new Date(endDate) || new Date(crisisEndDate) < new Date(startDate)) {
                          return null; // Don't render if crisis is outside current date range
                      }

                      if (crisis.date) {
                        return (
                          <ReferenceLine
                            key={crisis.name}
                            x={crisis.date}
                            stroke="rgba(255, 0, 0, 0.7)"
                            strokeDasharray="4 4"
                          >
                             <Label value={crisis.name} position="insideTopRight" fill="rgba(255,0,0,0.7)" fontSize={10} angle={-45} dy={-5} dx={5}/>
                          </ReferenceLine>
                        );
                      } else if (crisis.startDate && crisis.endDate) {
                        return (
                          <ReferenceArea
                            key={crisis.name}
                            x1={crisis.startDate}
                            x2={crisis.endDate}
                            fill="rgba(255, 0, 0, 0.1)"
                            stroke="rgba(255, 0, 0, 0.3)"
                          >
                            <Label value={crisis.name} position="insideTopRight" fill="rgba(255,0,0,0.7)" fontSize={10} angle={-45} dy={-5} dx={5}/>
                          </ReferenceArea>
                        );
                      }
                      return null;
                    })}
                  </LineChart>
                </ResponsiveContainer>
              ) : (
                !isLoading && <div className="h-full flex items-center justify-center">
                  <p className="text-gray-500">No data available or data is empty.</p>
                </div>
              )}
            </div>

            {/* Statistics */}
            {!isLoading && chartData.length > 0 && (
              <div className="bg-gray-50 p-4 rounded">
                <h3 className="text-lg font-semibold mb-2">Statistics ({selectedTransformation} data)</h3>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                  <div>
                    <p className="text-sm text-gray-500">Min</p>
                    <p className="text-xl font-medium">{math.min(chartData.map(d => d.value)).toFixed(2)}</p>
                  </div>
                  <div>
                    <p className="text-sm text-gray-500">Max</p>
                    <p className="text-xl font-medium">{math.max(chartData.map(d => d.value)).toFixed(2)}</p>
                  </div>
                  <div>
                    <p className="text-sm text-gray-500">Average</p>
                    <p className="text-xl font-medium">{math.mean(chartData.map(d => d.value)).toFixed(2)}</p>
                  </div>
                  <div>
                    <p className="text-sm text-gray-500">Std Dev</p>
                    <p className="text-xl font-medium">{math.std(chartData.map(d => d.value)).toFixed(2)}</p>
                  </div>
                </div>
              </div>
            )}
          </div>
        )}

        {/* Watchlist Tab */}
        {selectedTab === 'watchlist' && (
          <div className="bg-white shadow rounded-lg p-6">
            <h2 className="text-xl font-semibold mb-4">Your Watchlist</h2>
            {watchlist.length === 0 ? (
              <p className="text-gray-500">Your watchlist is empty. Add indicators from the Explore tab.</p>
            ) : (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {watchlist.map(item => (
                  <div key={item.id} className="border rounded-lg p-4">
                    <div className="flex justify-between items-start mb-2">
                      <div>
                        <h3 className="text-lg font-medium">{item.name}</h3>
                        <p className="text-sm text-gray-500">{item.source} ({item.indicator})</p>
                      </div>
                      <button
                        onClick={() => removeFromWatchlist(item.id)}
                        className="text-red-500 hover:text-red-700 text-sm"
                      >
                        Remove
                      </button>
                    </div>
                    <WatchlistItemChart item={item} />
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

        {/* Live Data Tab */}
        {selectedTab === 'live' && (
          <div className="bg-white shadow rounded-lg p-6">
            <h2 className="text-xl font-semibold mb-4">Live Data Feed</h2>
            <div className="mb-4">
              <div className="flex items-center gap-4 mb-6">
                <p className="text-sm font-medium">
                  Status: <span className={connectionStatus === 'Connected' ? 'text-green-600 font-semibold' : 'text-red-600 font-semibold'}>{connectionStatus}</span>
                </p>
                {connectionStatus !== 'Connected' ? (
                  <button
                    onClick={connectWebSocket}
                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm"
                  >
                    Connect to WebSocket
                  </button>
                ) : (
                  <button
                    onClick={disconnectWebSocket}
                    className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 text-sm"
                  >
                    Disconnect
                  </button>
                )}
              </div>
              <div className="p-4 bg-gray-50 rounded">
                <h3 className="text-lg font-medium mb-2">AWS WebSocket Connection (Simulation)</h3>
                <p className="text-sm text-gray-600 mb-4">
                  This section demonstrates a conceptual AWS WebSocket integration. In a real application, this would connect to an AWS API Gateway WebSocket API.
                </p>
                <div className="bg-gray-800 text-gray-200 p-3 rounded font-mono text-xs overflow-x-auto">
                  <pre>{`// Example AWS WebSocket Client Code (not active in this mock)
const socket = new WebSocket('wss://your-api-id.execute-api.region.amazonaws.com/stage');

socket.onopen = (event) => {
  console.log('Connected to AWS WebSocket API');
  // Subscribe to data feed
  socket.send(JSON.stringify({
    action: 'subscribe',
    indicators: ['UNRATE', 'GDP', 'FEDFUNDS']
  }));
};

socket.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log('Received data:', data);
  // updateLiveDataUI(data); // Function to update UI with live data
};

socket.onclose = () => {
  console.log('Disconnected from AWS WebSocket API');
};

socket.onerror = (error) => {
  console.error('WebSocket Error:', error);
};`}</pre>
                </div>
              </div>
            </div>
            <div className="mt-6">
              <h3 className="text-lg font-medium mb-2">AWS Setup Instructions (Conceptual)</h3>
              <div className="bg-gray-50 p-4 rounded">
                <ol className="list-decimal list-inside space-y-2 text-sm text-gray-700">
                  <li>Create an API Gateway WebSocket API in your AWS Console.</li>
                  <li>Define routes (e.g., `$connect`, `$disconnect`, `$default`, custom action routes).</li>
                  <li>Integrate routes with backend services (e.g., Lambda functions) to handle connections, subscriptions, and data broadcasting.</li>
                  <li>Lambda functions would manage connection IDs and publish data updates to subscribed clients using `ApiGatewayManagementApi`.</li>
                  <li>Deploy your API and update the WebSocket URL in your client application.</li>
                  <li>Implement authentication/authorization (e.g., Lambda authorizer).</li>
                </ol>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default Dashboard;