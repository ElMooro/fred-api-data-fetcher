# GitHub Terminal Commands for ProTrade Financial Analytics Platform

# 1. Create a new repository and initialize the project
mkdir protrade-financial-analytics
cd protrade-financial-analytics
git init
npm init -y

# 2. Install necessary dependencies
npm install chart.js@3.9.1 moment@2.29.4 chartjs-adapter-moment@1.0.1 chartjs-plugin-annotation@2.2.1 lodash@4.17.21

# 3. Create project structure
mkdir -p src/{js,css,assets}
mkdir -p src/js/{components,utils,services}

# 4. Create main files
touch index.html
touch src/js/main.js
touch src/css/styles.css
touch README.md

# 5. Add HTML content to index.html
cat > index.html << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProTrade Financial Analytics Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-adapter-moment/1.0.1/chartjs-adapter-moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/2.2.1/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash/4.17.21/lodash.min.js"></script>
    <link rel="stylesheet" href="src/css/styles.css">
</head>
<body>
    <!-- Copy the entire body content from the HTML code that was provided -->
    
    <script src="src/js/utils/helpers.js"></script>
    <script src="src/js/utils/technical-indicators.js"></script>
    <script src="src/js/services/data-service.js"></script>
    <script src="src/js/components/charts.js"></script>
    <script src="src/js/main.js"></script>
</body>
</html>
EOF

# 6. Create utility files for technical indicators
cat > src/js/utils/technical-indicators.js << 'EOF'
// Technical indicators calculations

function calculateSMA(data, period) {
    const result = [];
    
    for (let i = 0; i < data.length; i++) {
        if (i < period - 1) {
            result.push(null);
            continue;
        }
        
        let sum = 0;
        for (let j = 0; j < period; j++) {
            sum += data[i - j].close;
        }
        result.push(sum / period);
    }
    
    return result;
}

function calculateEMA(data, period) {
    const result = [];
    const k = 2 / (period + 1);
    
    // First EMA is SMA
    let ema = data.slice(0, period).reduce((sum, candle) => sum + candle.close, 0) / period;
    
    for (let i = 0; i < data.length; i++) {
        if (i < period - 1) {
            result.push(null);
            continue;
        }
        
        if (i === period - 1) {
            result.push(ema);
            continue;
        }
        
        ema = data[i].close * k + ema * (1 - k);
        result.push(ema);
    }
    
    return result;
}

function calculateBollingerBands(data, period = 20, multiplier = 2) {
    const middle = calculateSMA(data, period);
    const upper = [];
    const lower = [];
    
    for (let i = 0; i < data.length; i++) {
        if (i < period - 1) {
            upper.push(null);
            lower.push(null);
            continue;
        }
        
        let sum = 0;
        for (let j = 0; j < period; j++) {
            sum += Math.pow(data[i - j].close - middle[i], 2);
        }
        
        const stdDev = Math.sqrt(sum / period);
        upper.push(middle[i] + (multiplier * stdDev));
        lower.push(middle[i] - (multiplier * stdDev));
    }
    
    return { middle, upper, lower };
}

function calculateRSI(data, period = 14) {
    const result = [];
    const gains = [];
    const losses = [];
    
    // Calculate price changes
    for (let i = 0; i < data.length; i++) {
        if (i === 0) {
            gains.push(0);
            losses.push(0);
            result.push(null);
            continue;
        }
        
        const change = data[i].close - data[i-1].close;
        gains.push(change > 0 ? change : 0);
        losses.push(change < 0 ? Math.abs(change) : 0);
        
        if (i < period) {
            result.push(null);
            continue;
        }
        
        if (i === period) {
            const avgGain = gains.slice(1, period + 1).reduce((sum, val) => sum + val, 0) / period;
            const avgLoss = losses.slice(1, period + 1).reduce((sum, val) => sum + val, 0) / period;
            
            const rs = avgGain / (avgLoss === 0 ? 0.001 : avgLoss); // Avoid division by zero
            const rsi = 100 - (100 / (1 + rs));
            
            result.push(rsi);
            gains[i] = avgGain;
            losses[i] = avgLoss;
            continue;
        }
        
        const avgGain = (gains[i-1] * (period - 1) + gains[i]) / period;
        const avgLoss = (losses[i-1] * (period - 1) + losses[i]) / period;
        
        const rs = avgGain / (avgLoss === 0 ? 0.001 : avgLoss); // Avoid division by zero
        const rsi = 100 - (100 / (1 + rs));
        
        result.push(rsi);
        gains[i] = avgGain;
        losses[i] = avgLoss;
    }
    
    return result;
}

function calculateMACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
    const fastEMA = calculateEMA(data, fastPeriod);
    const slowEMA = calculateEMA(data, slowPeriod);
    const macdLine = [];
    
    // Calculate MACD Line
    for (let i = 0; i < data.length; i++) {
        if (i < slowPeriod - 1) {
            macdLine.push(null);
            continue;
        }
        
        macdLine.push(fastEMA[i] - slowEMA[i]);
    }
    
    // Calculate Signal Line (EMA of MACD Line)
    const signalLine = [];
    let signal = null;
    const k = 2 / (signalPeriod + 1);
    
    for (let i = 0; i < macdLine.length; i++) {
        if (i < slowPeriod + signalPeriod - 2) {
            signalLine.push(null);
            continue;
        }
        
        if (i === slowPeriod + signalPeriod - 2) {
            // First signal is SMA of MACD line
            let sum = 0;
            for (let j = 0; j < signalPeriod; j++) {
                sum += macdLine[i - j];
            }
            signal = sum / signalPeriod;
            signalLine.push(signal);
            continue;
        }
        
        signal = macdLine[i] * k + signal * (1 - k);
        signalLine.push(signal);
    }
    
    // Calculate Histogram
    const histogram = [];
    for (let i = 0; i < data.length; i++) {
        if (i < slowPeriod + signalPeriod - 2) {
            histogram.push(null);
            continue;
        }
        
        histogram.push(macdLine[i] - signalLine[i]);
    }
    
    return { macdLine, signalLine, histogram };
}

function calculateStochastic(data, period = 14, smoothK = 3, smoothD = 3) {
    const k = [];
    
    // Calculate %K
    for (let i = 0; i < data.length; i++) {
        if (i < period - 1) {
            k.push(null);
            continue;
        }
        
        let highestHigh = -Infinity;
        let lowestLow = Infinity;
        
        // Find highest high and lowest low in the period
        for (let j = 0; j < period; j++) {
            const currentPrice = data[i - j];
            highestHigh = Math.max(highestHigh, currentPrice.high);
            lowestLow = Math.min(lowestLow, currentPrice.low);
        }
        
        const range = highestHigh - lowestLow;
        
        // Calculate raw %K
        if (range === 0) {
            k.push(100); // Avoid division by zero
        } else {
            k.push(((data[i].close - lowestLow) / range) * 100);
        }
    }
    
    // Smooth %K
    const smoothedK = [];
    for (let i = 0; i < k.length; i++) {
        if (i < period - 1 + smoothK - 1) {
            smoothedK.push(null);
            continue;
        }
        
        let sum = 0;
        for (let j = 0; j < smoothK; j++) {
            sum += k[i - j];
        }
        
        smoothedK.push(sum / smoothK);
    }
    
    // Calculate %D (SMA of smoothed %K)
    const d = [];
    for (let i = 0; i < smoothedK.length; i++) {
        if (i < period - 1 + smoothK - 1 + smoothD - 1) {
            d.push(null);
            continue;
        }
        
        let sum = 0;
        for (let j = 0; j < smoothD; j++) {
            sum += smoothedK[i - j];
        }
        
        d.push(sum / smoothD);
    }
    
    return { k: smoothedK, d };
}

function calculateVWAP(data) {
    const result = [];
    let cumulativeTPV = 0; // Typical Price * Volume
    let cumulativeVolume = 0;
    
    // Get the first timestamp to determine if it's a new trading day
    const firstTimestamp = new Date(data[0].time);
    let currentDay = `${firstTimestamp.getFullYear()}-${firstTimestamp.getMonth()}-${firstTimestamp.getDate()}`;
    
    for (let i = 0; i < data.length; i++) {
        const timestamp = new Date(data[i].time);
        const dayKey = `${timestamp.getFullYear()}-${timestamp.getMonth()}-${timestamp.getDate()}`;
        
        // Reset VWAP calculation for a new trading day
        if (dayKey !== currentDay) {
            cumulativeTPV = 0;
            cumulativeVolume = 0;
            currentDay = dayKey;
        }
        
        const typicalPrice = (data[i].high + data[i].low + data[i].close) / 3;
        cumulativeTPV += typicalPrice * data[i].volume;
        cumulativeVolume += data[i].volume;
        
        if (cumulativeVolume === 0) {
            result.push(null);
        } else {
            result.push(cumulativeTPV / cumulativeVolume);
        }
    }
    
    return result;
}

function calculatePivotPoints(data, pivotType = 'standard') {
    // We need at least one complete period to calculate pivot points
    if (data.length < 2) return null;
    
    const result = [];
    
    // Define pivot point calculation functions
    const calculations = {
        standard: (high, low, close) => {
            const pp = (high + low + close) / 3;
            return {
                pp,
                r1: 2 * pp - low,
                s1: 2 * pp - high,
                r2: pp + (high - low),
                s2: pp - (high - low),
                r3: high + 2 * (pp - low),
                s3: low - 2 * (high - pp)
            };
        },
        fibonacci: (high, low, close) => {
            const pp = (high + low + close) / 3;
            return {
                pp,
                r1: pp + 0.382 * (high - low),
                s1: pp - 0.382 * (high - low),
                r2: pp + 0.618 * (high - low),
                s2: pp - 0.618 * (high - low),
                r3: pp + (high - low),
                s3: pp - (high - low)
            };
        },
        camarilla: (high, low, close) => {
            const range = high - low;
            return {
                pp: (high + low + close) / 3,
                r1: close + 1.1 * range / 12,
                s1: close - 1.1 * range / 12,
                r2: close + 1.1 * range / 6,
                s2: close - 1.1 * range / 6,
                r3: close + 1.1 * range / 4,
                s3: close - 1.1 * range / 4,
                r4: close + 1.1 * range / 2,
                s4: close - 1.1 * range / 2
            };
        },
        woodie: (high, low, close, open) => {
            const pp = (high + low + 2 * close) / 4;
            return {
                pp,
                r1: 2 * pp - low,
                s1: 2 * pp - high,
                r2: pp + (high - low),
                s2: pp - (high - low)
            };
        }
    };
    
    // Rest of the calculations...
    
    return result;
}
EOF

# 7. Create helper utilities
cat > src/js/utils/helpers.js << 'EOF'
// Helper functions

function formatDate(date) {
    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
}

function formatCurrency(value) {
    return ' + value.toFixed(2);
}

function formatNumber(num) {
    if (num >= 1000000) {
        return (num / 1000000).toFixed(2) + 'M';
    } else if (num >= 1000) {
        return (num / 1000).toFixed(2) + 'K';
    }
    return num.toString();
}

function showNotification(title, message) {
    const notification = document.createElement('div');
    notification.className = 'notification';
    notification.innerHTML = `
        <div class="notification-title">${title}</div>
        <div class="notification-message">${message}</div>
    `;
    
    document.body.appendChild(notification);
    
    // Show notification after a small delay
    setTimeout(() => {
        notification.classList.add('show');
    }, 10);
    
    // Auto-hide notification after a few seconds
    setTimeout(() => {
        notification.classList.remove('show');
        
        // Remove from DOM after animation completes
        setTimeout(() => {
            notification.remove();
        }, 300);
    }, 3000);
}
EOF

# 8. Create data service for handling API calls and mock data
cat > src/js/services/data-service.js << 'EOF'
// Data Service for handling API calls and mock data

// Mock data for development
const mockPriceData = {
    '1D': generateMockPriceData(24 * 4, 'hour'),
    '1W': generateMockPriceData(7 * 24, 'hour'),
    '1M': generateMockPriceData(30, 'day'),
    '3M': generateMockPriceData(90, 'day'),
    '6M': generateMockPriceData(180, 'day'),
    '1Y': generateMockPriceData(365, 'day'),
    '5Y': generateMockPriceData(5 * 365, 'week'),
    'MAX': generateMockPriceData(40 * 365, 'month')
};

function generateMockPriceData(numPoints, interval) {
    const data = [];
    let basePrice = 180 + Math.random() * 20;
    const volatility = 0.02;
    
    const now = new Date();
    let currentTime = new Date(now);
    
    // Adjust starting time based on interval
    switch(interval) {
        case 'hour':
            currentTime.setHours(currentTime.getHours() - numPoints);
            break;
        case 'day':
            currentTime.setDate(currentTime.getDate() - numPoints);
            break;
        case 'week':
            currentTime.setDate(currentTime.getDate() - (numPoints * 7));
            break;
        case 'month':
            currentTime.setMonth(currentTime.getMonth() - numPoints);
            break;
    }
    
    for (let i = 0; i < numPoints; i++) {
        const randomChange = (Math.random() - 0.5) * volatility * basePrice;
        basePrice = Math.max(150, Math.min(220, basePrice + randomChange));
        
        const open = basePrice - Math.random() * 2;
        const close = basePrice + Math.random() * 2;
        const high = Math.max(open, close) + Math.random() * 1.5;
        const low = Math.min(open, close) - Math.random() * 1.5;
        const volume = Math.floor(1000000 + Math.random() * 5000000);
        
        // Increment time based on interval
        let time = new Date(currentTime);
        switch(interval) {
            case 'hour':
                time.setHours(time.getHours() + i);
                break;
            case 'day':
                time.setDate(time.getDate() + i);
                break;
            case 'week':
                time.setDate(time.getDate() + (i * 7));
                break;
            case 'month':
                time.setMonth(time.getMonth() + i);
                break;
        }
        
        data.push({
            time: time,
            open: open,
            high: high,
            low: low,
            close: close,
            volume: volume
        });
    }
    
    return data;
}

// In a real application, this would be replaced with actual API calls
async function fetchPriceData(symbol, timeframe) {
    return new Promise((resolve) => {
        // Simulate API latency
        setTimeout(() => {
            resolve(mockPriceData[timeframe]);
        }, 500);
    });
}

// Example of how a real API call might look
// async function fetchRealPriceData(symbol, timeframe) {
//     try {
//         const response = await fetch(`https://api.example.com/prices?symbol=${symbol}&timeframe=${timeframe}`);
//         if (!response.ok) {
//             throw new Error('Failed to fetch price data');
//         }
//         return await response.json();
//     } catch (error) {
//         console.error('Error fetching price data:', error);
//         return mockPriceData[timeframe]; // Fallback to mock data
//     }
// }

// Function to simulate real-time data updates
function subscribeToRealtimeUpdates(symbol, callback) {
    // In a real app, this would establish a WebSocket connection
    console.log(`Subscribing to real-time updates for ${symbol}`);
    
    // For demo purposes, we'll use a timer to simulate updates
    const intervalId = setInterval(() => {
        const lastCandle = mockPriceData['1D'][mockPriceData['1D'].length - 1];
        const tick = {
            time: new Date(),
            open: lastCandle.close,
            high: lastCandle.close * (1 + Math.random() * 0.005),
            low: lastCandle.close * (1 - Math.random() * 0.005),
            close: lastCandle.close * (1 + (Math.random() - 0.5) * 0.01),
            volume: Math.floor(Math.random() * 100000)
        };
        
        callback(tick);
    }, 5000);
    
    // Return a function to unsubscribe
    return () => {
        clearInterval(intervalId);
        console.log(`Unsubscribed from real-time updates for ${symbol}`);
    };
}
EOF

# 9. Create chart components
cat > src/js/components/charts.js << 'EOF'
// Chart components

// Initialize charts
function initializeCharts() {
    // Main Price Chart
    const mainChartCtx = document.getElementById('mainChart').getContext('2d');
    
    // Create gradient for the area chart
    const areaGradient = mainChartCtx.createLinearGradient(0, 0, 0, 400);
    areaGradient.addColorStop(0, 'rgba(52, 152, 219, 0.2)');
    areaGradient.addColorStop(1, 'rgba(52, 152, 219, 0)');
    
    charts.mainChart = new Chart(mainChartCtx, {
        type: 'candlestick',
        data: {
            datasets: [{
                label: 'AAPL',
                data: [],
                color: {
                    up: 'rgba(46, 204, 113, 1)',
                    down: 'rgba(231, 76, 60, 1)',
                    unchanged: 'rgba(100, 100, 100, 1)',
                }
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'time',
                    time: {
                        unit: 'day',
                        displayFormats: {
                            day: 'MMM dd'
                        }
                    },
                    ticks: {
                        maxRotation: 0,
                        autoSkip: true,
                        maxTicksLimit: 10
                    }
                },
                y: {
                    position: 'right'
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    callbacks: {
                        label: function(context) {
                            const point = context.raw;
                            if (point) {
                                return [
                                    'Open: ' + formatCurrency(point.o),
                                    'High: ' + formatCurrency(point.h),
                                    'Low: ' + formatCurrency(point.l),
                                    'Close: ' + formatCurrency(point.c)
                                ];
                            }
                        }
                    }
                }
            }
        }
    });
    
    // Initialize other charts (Volume Profile, Order Flow, etc.)
    initializeVolumeProfileChart();
    initializeOrderFlowChart();
}

function initializeVolumeProfileChart() {
    const volumeProfileCtx = document.getElementById('volumeProfileChart').getContext('2d');
    charts.volumeProfile = new Chart(volumeProfileCtx, {
        type: 'bar',
        data: {
            labels: [],
            datasets: [{
                label: 'Volume',
                data: [],
                backgroundColor: 'rgba(52, 152, 219, 0.5)',
                borderColor: 'rgba(52, 152, 219, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            scales: {
                x: {
                    beginAtZero: true
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                annotation: {
                    annotations: {
                        line1: {
                            type: 'line',
                            yMin: 10,
                            yMax: 10,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 2,
                            label: {
                                content: 'POC',
                                enabled: true,
                                position: 'start'
                            }
                        }
                    }
                }
            }
        }
    });
}

function initializeOrderFlowChart() {
    const orderFlowCtx = document.getElementById('orderFlowChart').getContext('2d');
    charts.orderFlow = new Chart(orderFlowCtx, {
        type: 'bar',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Buy Volume',
                    data: [],
                    backgroundColor: 'rgba(46, 204, 113, 0.5)',
                    borderColor: 'rgba(46, 204, 113, 1)',
                    borderWidth: 1
                },
                {
                    label: 'Sell Volume',
                    data: [],
                    backgroundColor: 'rgba(231, 76, 60, 0.5)',
                    borderColor: 'rgba(231, 76, 60, 1)',
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: false,
                    type: 'time',
                    time: {
                        unit: 'day',
                        displayFormats: {
                            day: 'MMM dd'
                        }
                    },
                    ticks: {
                        maxRotation: 0,
                        autoSkip: true,
                        maxTicksLimit: 10
                    }
                },
                y: {
                    stacked: false,
                    beginAtZero: true
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top'
                }
            }
        }
    });
}

// Update charts with new data
function updateCharts(data) {
    // Update Main Chart
    const mainChartData = data.map(candle => ({
        x: candle.time,
        o: candle.open,
        h: candle.high,
        l: candle.low,
        c: candle.close
    }));
    
    charts.mainChart.data.datasets[0].data = mainChartData;
    
    // Add technical indicators if enabled
    updateTechnicalIndicators(data);
    
    // Update Volume Profile Chart
    updateVolumeProfileChart(data);
    
    // Update Order Flow Chart
    updateOrderFlowChart(data);
    
    // Update all charts
    charts.mainChart.update();
    charts.volumeProfile.update();
    charts.orderFlow.update();
}
EOF

# 10. Create main.js file
cat > src/js/main.js << 'EOF'
// Main application script

// Global variables
let charts = {};
let activeTimeframe = '3M';
let darkMode = false;
let currentSymbol = 'AAPL';
let indicators = {
    sma: false,
    ema: false,
    bollinger: false,
    ichimoku: false,
    volume: false,
    macd: false,
    rsi: false,
    stoch: false,
    vwap: false,
    pivots: false,
    fibonacci: false,
    patterns: false
};

// Initialize the app
function initializeApp() {
    // Set up initial theme based on user preference
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        toggleDarkMode();
    }
    
    // Initialize charts
    initializeCharts();
    
    // Load initial data
    loadChartData();
    
    // Set up event listeners
    setupEventListeners();
    
    // Initialize real-time data connection
    initializeRealTimeData();
}

// Load chart data
async function loadChartData() {
    // Show loading indicators
    document.getElementById('mainChartLoading').classList.add('active');
    document.getElementById('volumeProfileLoading').classList.add('active');
    document.getElementById('orderFlowLoading').classList.add('active');
    
    try {
        // Fetch data from service
        const data = await fetchPriceData(currentSymbol, activeTimeframe);
        
        // Update charts with new data
        updateCharts(data);
    } catch (error) {
        console.error('Error loading chart data:', error);
        showNotification('Error', 'Failed to load chart data. Please try again.');
    } finally {
        // Hide loading indicators
        document.getElementById('mainChartLoading').classList.remove('active');
        document.getElementById('volumeProfileLoading').classList.remove('active');
        document.getElementById('orderFlowLoading').classList.remove('active');
    }
}

// Set up event listeners
function setupEventListeners() {
    // Timeframe selector
    const timeframeButtons = document.querySelectorAll('.timeframe-btn');
    timeframeButtons.forEach(button => {
        button.addEventListener('click', () => {
            timeframeButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            activeTimeframe = button.getAttribute('data-timeframe');
            loadChartData();
        });
    });
    
    // Indicator toggle buttons
    document.getElementById('toggle-sma').addEventListener('click', () => {
        indicators.sma = !indicators.sma;
        document.getElementById('toggle-sma').classList.toggle('active', indicators.sma);
        loadChartData();
    });
    
    document.getElementById('toggle-ema').addEventListener('click', () => {
        indicators.ema = !indicators.ema;
        document.getElementById('toggle-ema').classList.toggle('active', indicators.ema);
        loadChartData();
    });
    
    document.getElementById('toggle-bollinger').addEventListener('click', () => {
        indicators.bollinger = !indicators.bollinger;
        document.getElementById('toggle-bollinger').classList.toggle('active', indicators.bollinger);
        loadChartData();
    });
    
    // Add more event listeners for other indicators...
    
    // Theme toggle
    document.getElementById('toggle-theme').addEventListener('click', toggleDarkMode);
    
    // Sidebar toggle
    document.getElementById('toggle-sidebar').addEventListener('click', () => {
        document.getElementById('sidebar').classList.toggle('sidebar-collapsed');
    });
    
    // Symbol search
    const symbolSearch = document.getElementById('symbol-search');
    symbolSearch.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            const newSymbol = symbolSearch.value.toUpperCase();
            if (newSymbol && newSymbol !== currentSymbol) {
                currentSymbol = newSymbol;
                document.querySelector('.dashboard-title').textContent = `${currentSymbol} - Loading...`;
                
                // Load new data for symbol
                loadChartData();
                
                // Update page title
                setTimeout(() => {
                    document.querySelector('.dashboard-title').textContent = `${currentSymbol} - Sample Stock Inc.`;
                    showNotification('Symbol Changed', `Loaded data for ${currentSymbol}`);
                }, 1000);
            }
        }
    });
    
    // Drawing tools
    const drawingTools = document.querySelectorAll('.toolbar-btn');
    drawingTools.forEach(tool => {
        tool.addEventListener('click', () => {
            drawingTools.forEach(t => t.classList.remove('active'));
            tool.classList.add('active');
            // In a real implementation, this would activate the corresponding drawing tool
            showNotification('Drawing Tool', `${tool.getAttribute('data-tooltip')} tool activated`);
        });
    });
}

// Toggle dark mode
function toggleDarkMode() {
    document.documentElement.classList.toggle('dark-theme');
    darkMode = document.documentElement.classList.contains('dark-theme');
    
    const lightIcon = document.querySelector('.light-icon');
    const darkIcon = document.querySelector('.dark-icon');
    
    if (darkMode) {
        lightIcon.style.display = 'none';
        darkIcon.style.display = 'block';
    } else {
        lightIcon.style.display = 'block';
        darkIcon.style.display = 'none';
    }
    
    // Update charts for better visibility in dark mode
    loadChartData();
}

// Initialize real-time data connection
function initializeRealTimeData() {
    // Only subscribe to real-time updates for 1D timeframe
    if (activeTimeframe === '1D') {
        const unsubscribe = subscribeToRealtimeUpdates(currentSymbol, (tick) => {
            // Update the last candle in the chart data
            const lastCandle = charts.mainChart.data.datasets[0].data[charts.mainChart.data.datasets[0].data.length - 1];
            
            // Update the last candle with the new tick
            lastCandle.h = Math.max(lastCandle.h, tick.high);
            lastCandle.l = Math.min(lastCandle.l, tick.low);
            lastCandle.c = tick.close;
            
            // Update the charts
            charts.mainChart.update();
        });
        
        // Store the unsubscribe function to clean up when changing timeframes
        window.currentUnsubscribe = unsubscribe;
    } else if (window.currentUnsubscribe) {
        // Unsubscribe from real-time updates when changing timeframes
        window.currentUnsubscribe();
        window.currentUnsubscribe = null;
    }
}

// Call initialization function when the DOM is loaded
document.addEventListener('DOMContentLoaded', initializeApp);
EOF

# 11. Set up styles.css (copy from the provided HTML)
cat > src/css/styles.css << 'EOF'
/* Copy the full CSS from the style tag in the provided HTML */
:root {
    /* Primary colors */
    --primary-dark: #1e2c3c;
    --primary: #2c3e50;
    --primary-light: #34495e;
    --secondary: #2980b9;
    --accent: #3498db;
    --success: #2ecc71;
    --warning: #f39c12;
    --danger: #e74c3c;
    --info: #3498db;
    
    /* Neutral colors */
    --dark: #121212;
    --dark-gray: #2c3e50;
    --medium-gray: #7f8c8d;
    --light-gray: #ecf0f1;
    --white: #ffffff;
    
    /* Chart colors */
    --chart-primary: rgba(52, 152, 219, 1);
    --chart-secondary: rgba(46, 204, 113, 1);
    --chart-tertiary: rgba(155, 89, 182, 1);
    --chart-quaternary: rgba(241, 196, 15, 1);
    --chart-quinary: rgba(231, 76, 60, 1);
    
    /* Font */
    --font-primary: 'Roboto', 'Segoe UI', sans-serif;
    --font-secondary: 'Open Sans', Arial, sans-serif;
    --font-mono: 'Roboto Mono', monospace;
    
    /* Sizing */
    --header-height: 60px;
    --sidebar-width: 260px;
    --border-radius: 6px;
    --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
}

/* Rest of the CSS from the provided HTML... */
EOF

# 12. Create a README file
cat > README.md << 'EOF'
# ProTrade Financial Analytics Platform

A powerful web-based platform for financial market analysis and trading with advanced charting and technical analysis tools.

## Features

- Advanced charting with multiple timeframes
- Technical indicators (SMA, EMA, MACD, RSI, etc.)
- Volume profile analysis
- Order flow analysis
- Pattern recognition
- Drawing tools
- Multi-timeframe analysis
- Options chain analysis
- Risk management tools
- AI-powered market insights
- Dark/light theme

## Setup

1. Clone the repository:
```
git clone https://github.com/yourusername/protrade-financial-analytics.git
cd protrade-financial-analytics
```

2. Open `index.html` in your browser.

## Development

This is a frontend-only application at the moment, using mock data for demonstration. In a production environment, you would need to:

1. Set up a backend API for real market data
2. Implement authentication
3. Configure real-time data streaming
4. Add data persistence

## Technologies Used

- HTML5/CSS3/JavaScript
- Chart.js for charting
- Moment.js for time handling
- Lodash for utility functions

## License

MIT
EOF

# 13. Add .gitignore file
cat > .gitignore << 'EOF'
# Dependencies
node_modules/
npm-debug.log
yarn-error.log
yarn-debug.log
.npm

# Build files
dist/
build/
.cache/

# IDE files
.idea/
.vscode/
*.sublime-project
*.sublime-workspace

# OS files
.DS_Store
Thumbs.db
EOF

# 14. Initialize git repository
git add .
git commit -m "Initial commit: ProTrade Financial Analytics Platform"

# 15. Create GitHub repository and push (you'll need to replace with your GitHub username)
# Note: You should first create a repo on GitHub through the web interface
echo "Now, create a repository on GitHub and run the following commands:"
echo "git remote add origin https://github.com/yourusername/protrade-financial-analytics.git"
echo "git push -u origin main"

# 16. Additional features - Adding more technical indicators and advanced features
cat > src/js/advanced-features.js << 'EOF'
// Advanced features for the ProTrade Financial Analytics Platform

// Pattern detection algorithms
function detectPatterns(data) {
    const patterns = [];
    
    // Detect Head and Shoulders pattern
    patterns.push(...detectHeadAndShoulders(data));
    
    // Detect Double Top/Double Bottom patterns
    patterns.push(...detectDoublePeaks(data));
    
    // Detect Triangle patterns
    patterns.push(...detectTriangles(data));
    
    // Detect Flag patterns
    patterns.push(...detectFlags(data));
    
    return patterns;
}

// Add pattern annotations to chart
function addPatternsToChart(chart, patterns) {
    // Clear existing annotations
    if (chart.options.plugins.annotation && chart.options.plugins.annotation.annotations) {
        chart.options.plugins.annotation.annotations = {};
    }
    
    // Add each pattern as an annotation
    patterns.forEach((pattern, index) => {
        const id = `pattern${index}`;
        
        // Add pattern annotation based on pattern type
        switch (pattern.type) {
            case 'headAndShoulders':
                addHeadAndShouldersAnnotation(chart, pattern, id);
                break;
            case 'doubleTop':
            case 'doubleBottom':
                addDoublePeakAnnotation(chart, pattern, id);
                break;
            case 'triangle':
                addTriangleAnnotation(chart, pattern, id);
                break;
            case 'flag':
                addFlagAnnotation(chart, pattern, id);
                break;
        }
    });
    
    // Update the chart
    chart.update();
}

// AI-powered insights generation
function generateAIInsights(data, symbol) {
    // This would connect to an AI service in a real application
    // For now, we'll generate some mock insights
    
    const insights = [];
    
    // Trend analysis
    const lastPrice = data[data.length - 1].close;
    const prices20d = data.slice(-20).map(candle => candle.close);
    const avgPrice20d = prices20d.reduce((sum, price) => sum + price, 0) / prices20d.length;
    
    if (lastPrice > avgPrice20d * 1.05) {
        insights.push({
            type: 'trend',
            icon: 'trending_up',
            title: 'Strong Uptrend Detected',
            message: `${symbol} is showing a strong uptrend, trading 5% above the 20-day average price.`,
            confidence: 85
        });
    } else if (lastPrice < avgPrice20d * 0.95) {
        insights.push({
            type: 'trend',
            icon: 'trending_down',
            title: 'Downtrend Alert',
            message: `${symbol} is in a downtrend, trading 5% below the 20-day average price.`,
            confidence: 78
        });
    }
    
    // Volume analysis
    const volumes20d = data.slice(-20).map(candle => candle.volume);
    const avgVolume20d = volumes20d.reduce((sum, vol) => sum + vol, 0) / volumes20d.length;
    const lastVolume = data[data.length - 1].volume;
    
    if (lastVolume > avgVolume20d * 2) {
        insights.push({
            type: 'volume',
            icon: 'signal_cellular_alt',
            title: 'Unusual Volume Spike',
            message: `Trading volume is more than 2x the 20-day average, indicating strong interest.`,
            confidence: 72
        });
    }
    
    // Pattern insights
    const patterns = detectPatterns(data);
    if (patterns.length > 0) {
        // Find the most recent pattern
        const latestPattern = patterns.reduce((latest, pattern) => {
            return pattern.endIndex > latest.endIndex ? pattern : latest;
        }, patterns[0]);
        
        insights.push({
            type: 'pattern',
            icon: 'auto_graph',
            title: `${latestPattern.type.charAt(0).toUpperCase() + latestPattern.type.slice(1)} Pattern Detected`,
            message: `A ${latestPattern.direction} ${latestPattern.type} pattern has formed, suggesting a potential ${latestPattern.direction === 'bullish' ? 'upward' : 'downward'} movement.`,
            confidence: 68
        });
    }
    
    return insights;
}

// Risk management calculator
function calculatePositionSize(accountSize, riskPercentage, entryPrice, stopLossPrice) {
    const riskAmount = accountSize * (riskPercentage / 100);
    const priceDistance = Math.abs(entryPrice - stopLossPrice);
    
    // Calculate position size in shares
    const positionSizeShares = Math.floor(riskAmount / priceDistance);
    
    // Calculate position size in currency
    const positionSizeCurrency = positionSizeShares * entryPrice;
    
    // Calculate max loss in currency
    const maxLoss = positionSizeShares * priceDistance;
    
    return {
        shares: positionSizeShares,
        currency: positionSizeCurrency,
        riskAmount: riskAmount,
        maxLoss: maxLoss,
        riskRewardRatio: null // This would be calculated once a target price is provided
    };
}

// Calculate potential profit/loss scenarios
function calculateProfitLossScenarios(entryPrice, positionSize, scenarios = [-0.1, -0.05, -0.02, 0, 0.02, 0.05, 0.1]) {
    return scenarios.map(percentChange => {
        const priceTarget = entryPrice * (1 + percentChange);
        const profitLoss = (priceTarget - entryPrice) * positionSize;
        const percentPL = (profitLoss / (entryPrice * positionSize)) * 100;
        
        return {
            percentChange: percentChange * 100,
            priceTarget: priceTarget,
            profitLoss: profitLoss,
            percentPL: percentPL
        };
    });
}

// Export functions to make them available to other modules
window.advancedFeatures = {
    detectPatterns,
    addPatternsToChart,
    generateAIInsights,
    calculatePositionSize,
    calculateProfitLossScenarios
};
EOF

echo "Advanced features script added!"

# 17. Add the script to index.html (would need to manually insert this in a real scenario)
echo "Remember to add the advanced-features.js script to your index.html:"
echo '<script src="src/js/advanced-features.js"></script>'

# 18. Push to GitHub
echo "Finally, push your changes to GitHub:"
echo "git add ."
echo "git commit -m \"Add advanced features and complete implementation\""
echo "git push origin main

# 19. Add backend integration instructions for production
echo "================================================="
echo "PRODUCTION BACKEND INTEGRATION INSTRUCTIONS"
echo "================================================="
echo "To implement a production-ready backend for this platform:"
echo ""
echo "1. Set up a Node.js Express server:"
echo "   mkdir -p server/src"
echo "   cd server"
echo "   npm init -y"
echo "   npm install express cors dotenv mongoose axios ws"
echo ""
echo "2. Create API routes for market data:"
echo "   touch src/routes/marketData.js"
echo "   touch src/controllers/marketDataController.js"
echo ""
echo "3. Implement WebSocket for real-time data:"
echo "   touch src/services/webSocketService.js"
echo ""
echo "4. Set up database for user preferences and watchlists:"
echo "   touch src/models/User.js"
echo "   touch src/models/Watchlist.js"
echo "   touch src/models/UserSettings.js"
echo ""
echo "5. Create authentication middleware:"
echo "   touch src/middleware/auth.js"
echo ""
echo "6. Set up environment variables:"
echo "   touch .env"
echo "   echo 'MONGODB_URI=your_mongodb_connection_string' >> .env"
echo "   echo 'JWT_SECRET=your_jwt_secret' >> .env"
echo "   echo 'MARKET_DATA_API_KEY=your_api_key' >> .env"
echo ""
echo "7. Create a docker-compose file for easy deployment:"
echo "   touch docker-compose.yml"
echo ""
echo "8. Update frontend to connect to backend:"
echo "   - Replace mock data services with real API calls"
echo "   - Add authentication flow"
echo "   - Implement WebSocket client for real-time data"
echo ""
echo "9. Deploy to production:"
echo "   - Set up CI/CD pipeline with GitHub Actions"
echo "   - Deploy to cloud provider (AWS, Google Cloud, etc.)"
echo "================================================="
"