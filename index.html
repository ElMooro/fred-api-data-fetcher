import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend,
  ResponsiveContainer, ReferenceLine, ReferenceArea, Label
} from 'recharts';
import * as math from 'mathjs';
import _ from 'lodash';

// Application version
const APP_VERSION = '2.0.0';

// Constants and configuration encapsulated in separate namespace objects
const CONFIG = {
  DATES: {
    DEFAULT_START_DATE: '2000-01-01',
    DEFAULT_END_DATE: '2025-04-30',
    DATE_FORMAT: 'YYYY-MM-DD'
  },
  RETRY: {
    MAX_ATTEMPTS: 3,
    BACKOFF_FACTOR: 1.5,
    INITIAL_DELAY: 1000, // ms
  },
  UI: {
    LOADING_TIMEOUT: 500, // ms
    DEBOUNCE_DELAY: 300, // ms
    CHART_HEIGHT: 96, // percentage
  },
  API: {
    DEFAULT_TIMEOUT: 5000 // ms
  }
};

// Financial Crisis Events
const FINANCIAL_CRISES = [
  { 
    name: "Black Monday", 
    date: "1987-10-19", 
    description: "Stock market crash where Dow Jones fell by 22.6%",
    severity: "high" 
  },
  { 
    name: "Dot-com Bubble", 
    startDate: "2000-03-10", 
    endDate: "2002-10-09", 
    description: "Tech stock bubble burst",
    severity: "high" 
  },
  { 
    name: "Global Financial Crisis", 
    startDate: "2007-12-01", 
    endDate: "2009-06-01", 
    description: "Subprime mortgage crisis",
    severity: "extreme" 
  },
  { 
    name: "Flash Crash", 
    date: "2010-05-06", 
    description: "Brief stock market crash with trillion-dollar losses",
    severity: "medium" 
  },
  { 
    name: "European Debt Crisis", 
    startDate: "2010-04-01", 
    endDate: "2012-07-26", 
    description: "Sovereign debt crisis in Europe",
    severity: "high" 
  },
  { 
    name: "COVID-19 Crash", 
    date: "2020-03-16", 
    description: "Pandemic-induced market crash",
    severity: "high" 
  }
];

// Data sources structured with proper TypeScript-style documentation
const DATA_SOURCES = {
  FRED: [
    { 
      id: "GDP", 
      name: "Gross Domestic Product", 
      frequency: "quarterly",
      unit: "Billions of USD",
      description: "Total value of goods and services produced",
      baseValue: 15000,
      volatility: 0.01,
      trend: 0.005
    },
    { 
      id: "UNRATE", 
      name: "Unemployment Rate", 
      frequency: "monthly",
      unit: "Percent",
      description: "Percentage of labor force unemployed",
      baseValue: 5,
      volatility: 0.03,
      trend: 0
    },
    { 
      id: "FEDFUNDS", 
      name: "Federal Funds Rate", 
      frequency: "monthly",
      unit: "Percent",
      description: "Interest rate at which banks lend to each other overnight",
      baseValue: 2.5,
      volatility: 0.02,
      trend: 0
    }
  ],
  ECB: [
    { 
      id: "EXR.D.USD.EUR.SP00.A", 
      name: "USD/EUR Exchange Rate", 
      frequency: "daily",
      unit: "USD per EUR",
      description: "Exchange rate between USD and EUR",
      baseValue: 1.1,
      volatility: 0.005,
      trend: 0
    },
    { 
      id: "MFI.M.U2.Y.V.M30.X.I.U2.2300.Z01.A", 
      name: "Eurozone M3 Money Supply", 
      frequency: "monthly",
      unit: "Percent Change",
      description: "Broad money supply growth in Eurozone",
      baseValue: 4.5,
      volatility: 0.02,
      trend: 0.001
    }
  ],
  NYFED: [
    { 
      id: "SOFR", 
      name: "Secured Overnight Financing Rate", 
      frequency: "daily",
      unit: "Percent",
      description: "Benchmark interest rate for dollar-denominated derivatives and loans",
      baseValue: 2.2,
      volatility: 0.01,
      trend: 0
    }
  ],
  OFR: [
    { 
      id: "FSI", 
      name: "Financial Stress Index", 
      frequency: "daily",
      unit: "Index",
      description: "Measure of systemic financial stress",
      baseValue: 0,
      volatility: 0.08,
      trend: 0
    }
  ]
};

// Transformations
const TRANSFORMATIONS = [
  { 
    id: "raw", 
    name: "Raw Data (No Transformation)", 
    description: "Original data without any mathematical transformation",
    requiresHistory: false 
  },
  { 
    id: "mom", 
    name: "Month-over-Month Change", 
    description: "Absolute change from previous month",
    requiresHistory: true,
    historyPeriod: "month"
  },
  { 
    id: "mom_pct", 
    name: "Month-over-Month % Change", 
    description: "Percentage change from previous month",
    requiresHistory: true,
    historyPeriod: "month",
    resultUnit: "percent"
  },
  { 
    id: "qoq", 
    name: "Quarter-over-Quarter Change", 
    description: "Absolute change from previous quarter",
    requiresHistory: true,
    historyPeriod: "quarter"
  },
  { 
    id: "qoq_pct", 
    name: "Quarter-over-Quarter % Change", 
    description: "Percentage change from previous quarter",
    requiresHistory: true,
    historyPeriod: "quarter",
    resultUnit: "percent"
  },
  { 
    id: "yoy", 
    name: "Year-over-Year % Change", 
    description: "Percentage change from same period previous year",
    requiresHistory: true,
    historyPeriod: "year",
    resultUnit: "percent"
  }
];

// Time frames
const TIME_FRAMES = [
  { id: "daily", name: "Daily", days: 1 },
  { id: "weekly", name: "Weekly", days: 7 },
  { id: "monthly", name: "Monthly", days: 30 },
  { id: "quarterly", name: "Quarterly", days: 90 },
  { id: "semiannual", name: "Half-Yearly", days: 180 },
  { id: "annual", name: "Yearly", days: 365 }
];

// Error types - Enables easier error handling and localization
const ERROR_TYPES = {
  INVALID_DATE_RANGE: 'INVALID_DATE_RANGE',
  INVALID_DATE_FORMAT: 'INVALID_DATE_FORMAT',
  NO_DATA_RETURNED: 'NO_DATA_RETURNED',
  DUPLICATE_WATCHLIST: 'DUPLICATE_WATCHLIST',
  TRANSFORMATION_ERROR: 'TRANSFORMATION_ERROR',
  NETWORK_ERROR: 'NETWORK_ERROR',
  API_ERROR: 'API_ERROR',
  GENERAL_ERROR: 'GENERAL_ERROR',
  DATA_SOURCE_ERROR: 'DATA_SOURCE_ERROR'
};

// Error messages - Centralized for easier localization
const ERROR_MESSAGES = {
  [ERROR_TYPES.INVALID_DATE_RANGE]: "Invalid date range. Please ensure start date is before end date.",
  [ERROR_TYPES.INVALID_DATE_FORMAT]: "Invalid date format. Please use YYYY-MM-DD format.",
  [ERROR_TYPES.NO_DATA_RETURNED]: "No data available for the selected parameters.",
  [ERROR_TYPES.DUPLICATE_WATCHLIST]: "This indicator is already in your watchlist.",
  [ERROR_TYPES.TRANSFORMATION_ERROR]: "Error applying transformation. Reverting to raw data.",
  [ERROR_TYPES.NETWORK_ERROR]: "Network connection error. Please try again.",
  [ERROR_TYPES.API_ERROR]: "API error. Some data sources may be unavailable.",
  [ERROR_TYPES.GENERAL_ERROR]: "An error occurred. Please try again.",
  [ERROR_TYPES.DATA_SOURCE_ERROR]: "Error with data source. Some indicators may be unavailable."
};

/**
 * UTILITY FUNCTIONS
 * Pure functions for data manipulation, error handling and logging
 */

/**
 * Logger utility with multiple log levels and environment awareness
 */
const Logger = (() => {
  const LOG_LEVELS = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3
  };
  
  // Set minimum log level based on environment
  const MIN_LOG_LEVEL = process.env.NODE_ENV === 'production' 
    ? LOG_LEVELS.WARN 
    : LOG_LEVELS.DEBUG;
  
  // Format message based on level and include timestamp
  const formatMessage = (level, message, data) => {
    const timestamp = new Date().toISOString();
    const formattedData = data ? JSON.stringify(data, null, 2) : '';
    return `[${timestamp}] [${level}] ${message} ${formattedData}`;
  };
  
  return {
    debug: (message, data) => {
      if (MIN_LOG_LEVEL <= LOG_LEVELS.DEBUG) {
        console.debug(formatMessage('DEBUG', message, data));
      }
    },
    info: (message, data) => {
      if (MIN_LOG_LEVEL <= LOG_LEVELS.INFO) {
        console.info(formatMessage('INFO', message, data));
      }
    },
    warn: (message, data) => {
      if (MIN_LOG_LEVEL <= LOG_LEVELS.WARN) {
        console.warn(formatMessage('WARN', message, data));
      }
    },
    error: (message, error, extraData) => {
      if (MIN_LOG_LEVEL <= LOG_LEVELS.ERROR) {
        console.error(
          formatMessage('ERROR', message, { 
            error: error?.message || error, 
            stack: error?.stack,
            ...extraData 
          })
        );
      }
    }
  };
})();

/**
 * Custom error class with type for better error handling
 */
class AppError extends Error {
  constructor(type, message, originalError = null) {
    super(message || ERROR_MESSAGES[type] || 'Unknown error');
    this.name = 'AppError';
    this.type = type;
    this.originalError = originalError;
  }
}

/**
 * Safely parse a date string and validate it
 * @param {string} dateString - Date string in YYYY-MM-DD format
 * @returns {Date|null} Parsed Date object or null if invalid
 */
const parseDate = (dateString) => {
  try {
    if (!dateString || typeof dateString !== 'string') {
      return null;
    }
    
    const date = new Date(dateString);
    return isNaN(date.getTime()) ? null : date;
  } catch (error) {
    Logger.error("Date parsing error:", error, { dateString });
    return null;
  }
};

/**
 * Validates a date range
 * @param {string} startDateStr - Start date in YYYY-MM-DD format
 * @param {string} endDateStr - End date in YYYY-MM-DD format
 * @throws {AppError} If dates are invalid or start date is after end date
 */
const validateDateRange = (startDateStr, endDateStr) => {
  const startDate = parseDate(startDateStr);
  const endDate = parseDate(endDateStr);
  
  if (!startDate || !endDate) {
    throw new AppError(ERROR_TYPES.INVALID_DATE_FORMAT);
  }
  
  if (startDate > endDate) {
    throw new AppError(ERROR_TYPES.INVALID_DATE_RANGE);
  }
  
  return { startDate, endDate };
};

/**
 * Safely get month difference between two dates
 * @param {Date} date1 - First date
 * @param {Date} date2 - Second date
 * @returns {number} Number of months between dates
 */
const getMonthDifference = (date1, date2) => {
  if (!date1 || !date2) return 0;
  return (date2.getFullYear() - date1.getFullYear()) * 12 + date2.getMonth() - date1.getMonth();
};

/**
 * Safely get quarter difference between two dates
 * @param {Date} date1 - First date
 * @param {Date} date2 - Second date
 * @returns {number} Number of quarters between dates
 */
const getQuarterDifference = (date1, date2) => {
  if (!date1 || !date2) return 0;
  const getQuarter = (date) => Math.floor(date.getMonth() / 3);
  return (date2.getFullYear() - date1.getFullYear()) * 4 + getQuarter(date2) - getQuarter(date1);
};

/**
 * Safely get year difference between two dates
 * @param {Date} date1 - First date
 * @param {Date} date2 - Second date
 * @returns {number} Number of years between dates
 */
const getYearDifference = (date1, date2) => {
  if (!date1 || !date2) return 0;
  return date2.getFullYear() - date1.getFullYear();
};

/**
 * Check if two dates are in the same month
 * @param {Date} date1 - First date
 * @param {Date} date2 - Second date
 * @returns {boolean} True if dates are in the same month
 */
const isSameMonth = (date1, date2) => {
  if (!date1 || !date2) return false;
  return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth();
};

/**
 * Check if two dates are in the same quarter
 * @param {Date} date1 - First date
 * @param {Date} date2 - Second date
 * @returns {boolean} True if dates are in the same quarter
 */
const isSameQuarter = (date1, date2) => {
  if (!date1 || !date2) return false;
  const getQuarter = (date) => Math.floor(date.getMonth() / 3);
  return date1.getFullYear() === date2.getFullYear() && getQuarter(date1) === getQuarter(date2);
};

/**
 * Check if two dates are in the same year
 * @param {Date} date1 - First date
 * @param {Date} date2 - Second date
 * @returns {boolean} True if dates are in the same year
 */
const isSameYear = (date1, date2) => {
  if (!date1 || !date2) return false;
  return date1.getFullYear() === date2.getFullYear();
};

/**
 * Format a number based on transformation type
 * @param {number} value - The value to format
 * @param {string} transformationType - The transformation type
 * @param {number} precision - Decimal precision (default: 2)
 * @returns {string} Formatted number as string
 */
const formatValue = (value, transformationType, precision = 2) => {
  if (value === null || value === undefined || isNaN(value)) {
    return 'N/A';
  }
  
  const isPercentage = transformationType?.includes('pct') || transformationType === 'yoy';
  return `${value.toFixed(precision)}${isPercentage ? '%' : ''}`;
};

/**
 * Create a retry wrapper for async functions with exponential backoff
 * @param {Function} fn - Async function to retry
 * @param {Object} options - Retry options
 * @param {number} options.maxAttempts - Maximum number of attempts
 * @param {number} options.backoffFactor - Multiplier for delay between attempts
 * @param {number} options.initialDelay - Initial delay in ms
 * @returns {Function} Function with retry capability
 */
const withRetry = (fn, options = {}) => {
  const {
    maxAttempts = CONFIG.RETRY.MAX_ATTEMPTS,
    backoffFactor = CONFIG.RETRY.BACKOFF_FACTOR,
    initialDelay = CONFIG.RETRY.INITIAL_DELAY
  } = options;
  
  return async (...args) => {
    let lastError;
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        return await fn(...args);
      } catch (error) {
        lastError = error;
        
        // Don't retry if it's a validation error or we've reached max attempts
        if (error instanceof AppError || attempt === maxAttempts) {
          throw error;
        }
        
        // Log retry attempt
        Logger.warn(`Retry attempt ${attempt}/${maxAttempts}`, { 
          function: fn.name, 
          error: error.message 
        });
        
        // Wait before next attempt with exponential backoff
        const delay = initialDelay * Math.pow(backoffFactor, attempt - 1);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    // This should never execute due to the throw in the loop, but as a fallback
    throw lastError;
  };
};

/**
 * Debounce function to prevent excessive function calls
 * @param {Function} func - Function to debounce
 * @param {number} wait - Wait time in milliseconds
 * @returns {Function} Debounced function
 */
const debounce = (func, wait = CONFIG.UI.DEBOUNCE_DELAY) => {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
};

/**
 * DATA SERVICE
 * Handles all data fetching, transformation, and caching
 */
const DataService = (() => {
  // In-memory cache for data
  const cache = new Map();
  
  /**
   * Generate a cache key for data requests
   * @param {string} seriesId - Indicator ID
   * @param {string} frequency - Data frequency
   * @param {string} startDate - Start date
   * @param {string} endDate - End date
   * @returns {string} Cache key
   */
  const getCacheKey = (seriesId, frequency, startDate, endDate) => {
    return `${seriesId}|${frequency}|${startDate}|${endDate}`;
  };

  /**
   * Find indicator details across all sources
   * @param {string} seriesId - Indicator ID to find
   * @returns {Object|null} Indicator details or null if not found
   */
  const findIndicatorDetails = (seriesId) => {
    if (!seriesId) return null;
    
    let indicatorDetails = null;
    Object.values(DATA_SOURCES).some(sourceData => {
      const found = sourceData.find(item => item.id === seriesId);
      if (found) {
        indicatorDetails = found;
        return true;
      }
      return false;
    });
    
    return indicatorDetails;
  };

  /**
   * Generates mock financial data with realistic patterns and proper error handling
   * @param {string} seriesId - Identifier for the data series
   * @param {string} frequency - Data frequency (daily, weekly, monthly, etc.)
   * @param {string} startDate - Start date in ISO format
   * @param {string} endDate - End date in ISO format
   * @returns {Promise<Array>} Array of data points with date and value properties
   */
  const generateMockData = async (seriesId, frequency, startDate, endDate) => {
    try {
      // Input validation
      if (!seriesId) {
        throw new AppError(ERROR_TYPES.GENERAL_ERROR, "Missing series ID parameter");
      }
      
      if (!frequency) {
        throw new AppError(ERROR_TYPES.GENERAL_ERROR, "Missing frequency parameter");
      }
      
      // Validate date range
      const { startDate: start, endDate: end } = validateDateRange(startDate, endDate);
      
      // Check cache first
      const cacheKey = getCacheKey(seriesId, frequency, startDate, endDate);
      if (cache.has(cacheKey)) {
        Logger.debug("Cache hit", { cacheKey });
        return cache.get(cacheKey);
      }
      
      // Find indicator details
      const indicatorDetails = findIndicatorDetails(seriesId);
      
      // Default values if indicator not found
      const baseValue = indicatorDetails?.baseValue || 100;
      const volatilityFactor = indicatorDetails?.volatility || 0.03;
      const trendFactor = indicatorDetails?.trend || 0;
      
      // Generate data
      const data = [];
      let currentDate = new Date(start);
      
      // Economic cycle simulation (approximates ~8 year business cycle)
      const cycleDays = 365 * 8;
      let cyclePosition = 0;
      let value = baseValue;
      
      while (currentDate <= end) {
        try {
          // Combine random volatility, trend, and cyclical components
          const randomComponent = (Math.random() * volatilityFactor * 2) - volatilityFactor;
          const trendComponent = trendFactor;
          
          // Cyclical component - sinusoidal wave with ~8 year period
          let cyclicalComponent = 0;
          if (seriesId === "GDP" || seriesId === "UNRATE") {
            cyclicalComponent = Math.sin(2 * Math.PI * cyclePosition / cycleDays) * volatilityFactor;
            
            // Unemployment is countercyclical
            if (seriesId === "UNRATE") {
              cyclicalComponent *= -1;
            }
          }
          
          // Crisis impacts
          let crisisComponent = 0;
          FINANCIAL_CRISES.forEach(crisis => {
            const crisisDate = crisis.date ? new Date(crisis.date) : null;
            const crisisStartDate = crisis.startDate ? new Date(crisis.startDate) : null;
            const crisisEndDate = crisis.endDate ? new Date(crisis.endDate) : null;
            
            // For single-day crisis events
            if (crisisDate) {
              const daysSinceCrisis = Math.abs((currentDate - crisisDate) / (24 * 60 * 60 * 1000));
              if (daysSinceCrisis <= 30) { // Impact most pronounced within 30 days
                const severityMultiplier = crisis.severity === "extreme" ? 2 : 
                                        crisis.severity === "high" ? 1 : 0.5;
                                        
                // Different impact based on indicator type
                if (seriesId === "FSI" || seriesId === "UNRATE") {
                  // Stress index and unemployment spike up during crises
                  crisisComponent += (0.2 * severityMultiplier) * Math.exp(-daysSinceCrisis / 15);
                } else if (seriesId === "GDP") {
                  // GDP drops during crises
                  crisisComponent -= (0.15 * severityMultiplier) * Math.exp(-daysSinceCrisis / 20);
                }
              }
            }
            
            // For crisis periods
            if (crisisStartDate && crisisEndDate) {
              if (currentDate >= crisisStartDate && currentDate <= crisisEndDate) {
                const severityMultiplier = crisis.severity === "extreme" ? 2 : 
                                        crisis.severity === "high" ? 1 : 0.5;
                
                // Position within crisis period (0 to 1)
                const crisisDuration = (crisisEndDate - crisisStartDate) / (24 * 60 * 60 * 1000);
                const daysIntoCrisis = (currentDate - crisisStartDate) / (24 * 60 * 60 * 1000);
                const crisisPosition = daysIntoCrisis / crisisDuration;
                
                // Different impact patterns based on indicator and position in crisis
                if (seriesId === "FSI") {
                  // Stress index rises quickly, stays high, falls at end
                  crisisComponent += (0.15 * severityMultiplier) * 
                                    (crisisPosition < 0.2 ? crisisPosition * 5 : 
                                    crisisPosition > 0.8 ? (1 - crisisPosition) * 5 : 1);
                } else if (seriesId === "UNRATE") {
                  // Unemployment rises throughout crisis
                  crisisComponent += (0.1 * severityMultiplier) * Math.min(1, crisisPosition * 2);
                } else if (seriesId === "GDP") {
                  // GDP falls, then slowly recovers
                  crisisComponent -= (0.1 * severityMultiplier) * (1 - Math.min(1, crisisPosition * 3));
                }
              }
            }
          });
          
          // Combine all components
          const totalChange = randomComponent + trendComponent + cyclicalComponent + crisisComponent;
          
          // For percentage indicators, use additive
          if (seriesId === "UNRATE" || seriesId === "FEDFUNDS") {
            value += value * totalChange;
          } else {
            // For index values, use multiplicative
            value = value * (1 + totalChange);
          }
          
          // Ensure no negative values for certain indicators
          if ((seriesId === "UNRATE" || seriesId === "FEDFUNDS" || seriesId === "GDP") && value < 0) {
            value = Math.abs(value * 0.1); // Small positive value
          }
          
          // Ensure realistic ranges for specific indicators
          if (seriesId === "UNRATE" && value > 25) value = 25;
          if (seriesId === "FEDFUNDS" && value > 20) value = 20;
          
          data.push({
            date: currentDate.toISOString().split('T')[0],
            value: parseFloat(value.toFixed(2)),
            rawValue: parseFloat(value.toFixed(2)) // Keep original for reference
          });
        } catch (innerError) {
          // Log error but continue with data generation
          Logger.error("Error generating data point", innerError, {
            seriesId,
            date: currentDate.toISOString()
          });
          // Skip this data point but continue with the next one
        }
        
        // Increment cycle position
        cyclePosition++;
        
        // Move to next period based on frequency
        if (frequency === 'daily') {
          currentDate.setDate(currentDate.getDate() + 1);
        } else if (frequency === 'weekly') {
          currentDate.setDate(currentDate.getDate() + 7);
        } else if (frequency === 'monthly') {
          currentDate.setMonth(currentDate.getMonth() + 1);
        } else if (frequency === 'quarterly') {
          currentDate.setMonth(currentDate.getMonth() + 3);
        } else if (frequency === 'semiannual') {
          currentDate.setMonth(currentDate.getMonth() + 6);
        } else if (frequency === 'annual') {
          currentDate.setFullYear(currentDate.getFullYear() + 1);
        } else {
          // Default to monthly if frequency is unknown
          currentDate.setMonth(currentDate.getMonth() + 1);
        }
      }
      
      if (data.length === 0) {
        throw new AppError(ERROR_TYPES.NO_DATA_RETURNED);
      }
      
      // Store in cache
      cache.set(cacheKey, data);
      
      return data;
    } catch (error) {
      // Convert to AppError if it's not already
      if (!(error instanceof AppError)) {
        error = new AppError(
          ERROR_TYPES.DATA_SOURCE_ERROR,
          `Error generating data for ${seriesId}`,
          error
        );
      }
      
      Logger.error("Data generation error", error, {
        seriesId,
        frequency,
        startDate,
        endDate
      });
      
      throw error;
    }
  };

  /**
   * Transform data based on selected transformation type with robust error handling
   * @param {Array} data - Array of data points with date and value properties
   * @param {string} transformationType - Type of transformation to apply
   * @returns {Array} Transformed data
   */
  const transformData = (data, transformationType) => {
    try {
      // Early exit for raw data or invalid inputs
      if (!data || data.length === 0) {
        return [];
      }
      
      if (!transformationType || transformationType === 'raw') {
        return [...data]; // Return a copy of the original data
      }
  
      // Create a deep copy to avoid mutating the original data
      const sortedData = _.cloneDeep(data).sort((a, b) => new Date(a.date) - new Date(b.date));
      
      // Get transformation details
      const transformInfo = TRANSFORMATIONS.find(t => t.id === transformationType);
      if (!transformInfo) {
        Logger.warn(`Unknown transformation type: ${transformationType}`);
        return [...data]; // Return original data if transformation not found
      }
      
      switch (transformationType) {
        case 'mom': // Month-over-Month absolute change
          return sortedData.map((item, index) => {
            if (index === 0) return { ...item, value: 0 };
            
            const currentDate = parseDate(item.date);
            const prevDate = parseDate(sortedData[index - 1].date);
            
            // Only calculate changes between different months
            if (currentDate && prevDate && !isSameMonth(currentDate, prevDate)) {
              return {
                ...item,
                value: parseFloat((item.value - sortedData[index - 1].value).toFixed(2))
              };
            }
            
            return item;
          });
          
        case 'mom_pct': // Month-over-Month percentage change
          return sortedData.map((item, index) => {
            if (index === 0) return { ...item, value: 0 };
            
            const currentDate = parseDate(item.date);
            const prevDate = parseDate(sortedData[index - 1].date);
            
            // Only calculate changes between different months
            if (currentDate && prevDate && !isSameMonth(currentDate, prevDate)) {
              const prevValue = sortedData[index - 1].value;
              
              if (prevValue === 0) {
                return { ...item, value: 0 }; // Avoid division by zero
              }
              
              return {
                ...item,
                value: parseFloat(((item.value - prevValue) / Math.abs(prevValue) * 100).toFixed(2))
              };
            }
            
            return item;
          });
          
        case 'qoq': // Quarter-over-Quarter absolute change
          return sortedData.map((item, index) => {
            if (index === 0) return { ...item, value: 0 };
            
            const currentDate = parseDate(item.date);
            const prevDate = parseDate(sortedData[index - 1].date);
            
            // Only calculate changes between different quarters
            if (currentDate && prevDate && !isSameQuarter(currentDate, prevDate)) {
              return {
                ...item,
                value: parseFloat((item.value - sortedData[index - 1].value).toFixed(2))
              };
            }
            
            return item;
          });
          
        case 'qoq_pct': // Quarter-over-Quarter percentage change
          return sortedData.map((item, index) => {
            if (index === 0) return { ...item, value: 0 };
            
            const currentDate = parseDate(item.date);
            const prevDate = parseDate(sortedData[index - 1].date);
            
            // Only calculate changes between different quarters
            if (currentDate && prevDate && !isSameQuarter(currentDate, prevDate)) {
              const prevValue = sortedData[index - 1].value;
              
              if (prevValue === 0) {
                return { ...item, value: 0 }; // Avoid division by zero
              }
              
              return {
                ...item,
                value: parseFloat(((item.value - prevValue) / Math.abs(prevValue) * 100).toFixed(2))
              };
            }
            
            return item;
          });
          
        case 'yoy': // Year-over-Year percentage change
          return sortedData.map((item) => {
            const currentDate = parseDate(item.date);
            if (!currentDate) return { ...item, value: null };
            
            // Find data from approximately one year ago
            const yearAgoTarget = new Date(currentDate);
            yearAgoTarget.setFullYear(yearAgoTarget.getFullYear() - 1);
            
            // Find the closest matching data point from a year ago
            const yearAgoData = sortedData.find(d => {
              const dataDate = parseDate(d.date);
              return dataDate && Math.abs(dataDate - yearAgoTarget) < 16 * 24 * 60 * 60 * 1000; // Within ~15 days
            });
            
            if (!yearAgoData) {
              return { ...item, value: null }; // No year-ago data available
            }
            
            if (yearAgoData.value === 0) {
              return { ...item, value: null }; // Avoid division by zero
            }
            
            return {
              ...item,
              value: parseFloat(((item.value - yearAgoData.value) / Math.abs(yearAgoData.value) * 100).toFixed(2))
            };
          }).filter(item => item.value !== null); // Remove null values
          
        default:
          Logger.warn(`Transformation type '${transformationType}' not implemented, returning raw data`);
          return [...data];
      }
    } catch (error) {
      Logger.error("Error transforming data:", error, { transformationType });
      // Return original data on error
      return [...data];
    }
  };

  /**
   * Calculate statistics for a dataset with error handling
   * @param {Array} data - Array of data points
   * @returns {Object} Statistics object with min, max, mean, median, stdDev properties
   */
  const calculateStatistics = (data) => {
    if (!data || data.length === 0) {
      return {
        min: 0,
        max: 0,
        mean: 0,
        median: 0,
        stdDev: 0,
        count: 0
      };
    }
    
    try {
      const values = data.map(d => d.value).filter(v => v !== null && !isNaN(v));
      
      if (values.length === 0) {
        return {
          min: 0,
          max: 0,
          mean: 0,
          median: 0,
          stdDev: 0,
          count: 0
        };
      }
      
      return {
        min: math.min(values),
        max: math.max(values),
        mean: math.mean(values),
        median: math.median(values),
        stdDev: math.std(values),
        count: values.length
      };
    } catch (error) {
      Logger.error("Error calculating statistics:", error);
      return {
        min: 0,
        max: 0,
        mean: 0,
        median: 0,
        stdDev: 0,
        count: 0,
        error: error.message
      };
    }
  };

  // Wrap data fetching with retry capability
  const fetchDataWithRetry = withRetry(generateMockData);

  // Expose public API
  return {
    fetchData: fetchDataWithRetry,
    transformData,
    calculateStatistics,
    findIndicatorDetails
  };
})();

/**
 * Custom hook for local storage state with error handling
 * @param {string} key - Local storage key
 * @param {any} initialValue - Initial value
 * @returns {Array} State and setState function
 */
const useLocalStorage = (key, initialValue) => {
  // State to store our value
  const [storedValue, setStoredValue] = useState(() => {
    try {
      // Get from local storage by key
      const item = window.localStorage.getItem(key);
      // Parse stored json or if none return initialValue
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      Logger.error("Error reading from localStorage:", error, { key });
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that persists the new value to localStorage
  const setValue = (value) => {
    try {
      // Allow value to be a function so we have same API as useState
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      // Save state
      setStoredValue(valueToStore);
      // Save to local storage
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      Logger.error("Error writing to localStorage:", error, { key });
      // Still update state even if localStorage fails
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
    }
  };

  return [storedValue, setValue];
};

/**
 * Error message component
 */
const ErrorMessage = React.memo(({ message, onDismiss }) => {
  if (!message) return null;
  
  return (
    <div 
      className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-6 rounded flex justify-between items-center" 
      role="alert"
      aria-live="assertive"
    >
      <p>{message}</p>
      <button 
        className="text-red-700 font-bold hover:text-red-900 ml-2 focus:outline-none focus:ring-2 focus:ring-red-500"
        onClick={onDismiss}
        aria-label="Dismiss error"
      >
        âœ•
      </button>
    </div>
  );
});

// Set display name for React DevTools
ErrorMessage.displayName = 'ErrorMessage';

/**
 * Loading indicator component
 */
const LoadingIndicator = React.memo(({ message = "Loading..." }) => (
  <div className="h-full flex items-center justify-center" aria-busy="true" role="status">
    <div className="flex flex-col items-center">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mb-2"></div>
      <p className="text-gray-500">{message}</p>
    </div>
  </div>
));

LoadingIndicator.displayName = 'LoadingIndicator';

/**
 * Empty state component
 */
const EmptyState = React.memo(({ message, action, actionLabel }) => (
  <div className="h-full flex items-center justify-center">
    <div className="bg-gray-50 p-8 rounded-lg text-center max-w-md">
      <p className="text-gray-500 mb-4">{message}</p>
      {action && actionLabel && (
        <button
          onClick={action}
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition duration-150 focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          {actionLabel}
        </button>
      )}
    </div>
  </div>
));

EmptyState.displayName = 'EmptyState';

/**
 * Watchlist item chart component with error boundaries
 */
const WatchlistItemChart = React.memo(({ item }) => {
  const [itemData, setItemData] = useState([]);
  const [isItemLoading, setIsItemLoading] = useState(true);
  const [itemError, setItemError] = useState('');

  useEffect(() => {
    let isMounted = true;
    setIsItemLoading(true);
    setItemError('');
    
    const loadData = async () => {
      try {
        // Generate data once when item props change
        const data = await DataService.fetchData(
          item.indicator,
          item.frequency,
          item.startDate,
          item.endDate
        );
        
        if (!isMounted) return;
        
        if (!data || data.length === 0) {
          throw new AppError(ERROR_TYPES.NO_DATA_RETURNED);
        }
        
        // Apply transformation if needed
        const transformedData = item.transformation !== 'raw' 
          ? DataService.transformData(data, item.transformation)
          : data;
          
        setItemData(transformedData);
        setIsItemLoading(false);
      } catch (error) {
        if (!isMounted) return;
        
        Logger.error(`Error loading watchlist item ${item.id}:`, error);
        setItemError(error instanceof AppError ? error.message : ERROR_MESSAGES.GENERAL_ERROR);
        setIsItemLoading(false);
        setItemData([]); // Clear data on error
      }
    };
    
    loadData();
    
    return () => {
      isMounted = false;
    };
  }, [item.indicator, item.frequency, item.startDate, item.endDate, item.transformation, item.id]);

  if (isItemLoading) {
    return <LoadingIndicator message="Loading chart data..." />;
  }

  if (itemError) {
    return (
      <div className="h-48 flex items-center justify-center">
        <p className="text-red-500 text-xs">{itemError}</p>
      </div>
    );
  }

  if (!itemData.length) {
    return (
      <div className="h-48 flex items-center justify-center">
        <p className="text-gray-400 text-xs">No data available</p>
      </div>
    );
  }

  const transformInfo = TRANSFORMATIONS.find(t => t.id === item.transformation) || {};
  const isPercentage = transformInfo.resultUnit === 'percent';

  return (
    <div className="h-48">
      <ResponsiveContainer width="100%" height="100%">
        <LineChart
          data={itemData}
          margin={{ top: 5, right: 20, left: -20, bottom: 5 }}
        >
          <XAxis 
            dataKey="date" 
            tick={{ fontSize: 10 }} 
            interval="preserveStartEnd" 
            tickFormatter={(tick) => new Date(tick).getFullYear()} 
          />
          <YAxis 
            tick={{ fontSize: 10 }} 
            domain={['auto', 'auto']} 
            tickFormatter={(value) => isPercentage ? `${value}%` : value}
          />
          <Tooltip 
            contentStyle={{ fontSize: '10px' }}
            formatter={(value) => [
              `${parseFloat(value).toFixed(2)}${isPercentage ? '%' : ''}`,
              `${item.transformationName || 'Value'}`
            ]}
            labelFormatter={(label) => new Date(label).toLocaleDateString()}
          />
          <Line 
            type="monotone" 
            dataKey="value" 
            stroke="#3B82F6" 
            dot={false} 
            strokeWidth={1.5}
            name={item.name}
            isAnimationActive={false} // Disable animation for performance
          />
        </LineChart>
      </ResponsiveContainer>
    </div>
  );
});

WatchlistItemChart.displayName = 'WatchlistItemChart';

/**
 * WebSocket service for live data
 */
const WebSocketService = (() => {
  let socket = null;
  let isConnected = false;
  let reconnectTimeout = null;
  let reconnectAttempts = 0;
  let messageHandlers = new Set();
  let connectionStatusHandlers = new Set();
  
  const MAX_RECONNECT_ATTEMPTS = 5;
  const RECONNECT_DELAY = 2000;
  
  const updateConnectionStatus = (status) => {
    isConnected = status === 'Connected';
    connectionStatusHandlers.forEach(handler => handler(status));
  };
  
  const connect = () => {
    if (socket) {
      return;
    }
    
    try {
      updateConnectionStatus('Connecting...');
      
      // In a real app, this would connect to an actual WebSocket server
      // For simulation purposes, we use a timeout
      setTimeout(() => {
        updateConnectionStatus('Connected');
        reconnectAttempts = 0;
        
        // Simulate receiving data periodically
        const interval = setInterval(() => {
          if (!isConnected) {
            clearInterval(interval);
            return;
          }
          
          const mockData = {
            type: 'update',
            timestamp: new Date().toISOString(),
            data: {
              UNRATE: {
                value: (4 + Math.random() * 2).toFixed(2),
                change: (Math.random() * 0.4 - 0.2).toFixed(2)
              },
              GDP: {
                value: (21500 + Math.random() * 500).toFixed(2),
                change: (Math.random() * 1 - 0.3).toFixed(2)
              },
              FEDFUNDS: {
                value: (3 + Math.random() * 1).toFixed(2),
                change: (Math.random() * 0.2 - 0.1).toFixed(2)
              }
            }
          };
          
          messageHandlers.forEach(handler => handler(mockData));
        }, 5000);
        
        // Store the interval for cleanup
        socket = { interval };
        
      }, 1000);
    } catch (error) {
      Logger.error("WebSocket connection error", error);
      updateConnectionStatus('Connection Error');
      reconnect();
    }
  };
  
  const disconnect = () => {
    if (socket) {
      clearInterval(socket.interval);
      socket = null;
    }
    
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
      reconnectTimeout = null;
    }
    
    updateConnectionStatus('Disconnected');
  };
  
  const reconnect = () => {
    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
      updateConnectionStatus('Reconnect Failed');
      return;
    }
    
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
    }
    
    reconnectAttempts++;
    updateConnectionStatus(`Reconnecting (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
    
    reconnectTimeout = setTimeout(() => {
      socket = null;
      connect();
    }, RECONNECT_DELAY * reconnectAttempts);
  };
  
  const onMessage = (handler) => {
    messageHandlers.add(handler);
    return () => messageHandlers.delete(handler);
  };
  
  const onConnectionStatusChange = (handler) => {
    connectionStatusHandlers.add(handler);
    handler(isConnected ? 'Connected' : 'Disconnected'); // Initial status
    return () => connectionStatusHandlers.delete(handler);
  };
  
  return {
    connect,
    disconnect,
    onMessage,
    onConnectionStatusChange,
    isConnected: () => isConnected
  };
})();

/**
 * Main Dashboard component
 */
const Dashboard = () => {
  // State management
  const [selectedSource, setSelectedSource] = useState('FRED');
  const [selectedIndicator, setSelectedIndicator] = useState('UNRATE');
  const [selectedTimeFrame, setSelectedTimeFrame] = useState('monthly');
  const [selectedTransformation, setSelectedTransformation] = useState('raw');
  const [rawData, setRawData] = useState([]);
  const [chartData, setChartData] = useState([]);
  const [startDate, setStartDate] = useState(CONFIG.DATES.DEFAULT_START_DATE);
  const [endDate, setEndDate] = useState(CONFIG.DATES.DEFAULT_END_DATE);
  const [isLoading, setIsLoading] = useState(false);
  const [watchlist, setWatchlist] = useLocalStorage('financial-dashboard-watchlist', []);
  const [selectedTab, setSelectedTab] = useState('explore');
  const [connectionStatus, setConnectionStatus] = useState('Disconnected');
  const [error, setError] = useState('');
  const [lastUpdated, setLastUpdated] = useState(null);
  const [liveData, setLiveData] = useState({});
  
  // Get details of the currently selected indicator
  const getIndicatorDetails = useCallback(() => {
    const sourceData = DATA_SOURCES[selectedSource] || [];
    return sourceData.find(item => item.id === selectedIndicator) || {};
  }, [selectedSource, selectedIndicator]);

  // Get transformation details
  const getTransformationDetails = useCallback(() => {
    return TRANSFORMATIONS.find(item => item.id === selectedTransformation) || {};
  }, [selectedTransformation]);

  // Fetch data with error handling and debouncing for frequent calls
  const fetchData = useCallback(debounce(() => {
    setIsLoading(true);
    setError('');
    
    // Validate inputs before making request
    try {
      validateDateRange(startDate, endDate);
    } catch (validationError) {
      setError(validationError.message);
      setIsLoading(false);
      return;
    }
    
    const indicatorDetails = getIndicatorDetails();
    if (!indicatorDetails) {
      setError("Invalid indicator selected");
      setIsLoading(false);
      return;
    }
    
    // Use the data service to fetch data
    DataService.fetchData(
      selectedIndicator,
      indicatorDetails.frequency || 'monthly',
      startDate,
      endDate
    )
      .then(data => {
        setRawData(data);
        setLastUpdated(new Date());
        setIsLoading(false);
      })
      .catch(error => {
        setError(error instanceof AppError ? error.message : ERROR_MESSAGES.GENERAL_ERROR);
        setIsLoading(false);
        // Don't clear existing data on error to maintain partial functionality
      });
  }, CONFIG.UI.DEBOUNCE_DELAY), [selectedIndicator, getIndicatorDetails, startDate, endDate]);

  // Initial data load
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Apply transformations when rawData or selectedTransformation changes
  useEffect(() => {
    if (rawData.length === 0) {
      setChartData([]);
      return;
    }

    try {
      const transformed = DataService.transformData(rawData, selectedTransformation);
      setChartData(transformed);
    } catch (error) {
      Logger.error("Error applying transformation:", error);
      setError(ERROR_MESSAGES.TRANSFORMATION_ERROR);
      // Fall back to raw data on error
      setChartData([...rawData]);
    }
  }, [rawData, selectedTransformation]);

  // Add current selection to watchlist
  const addToWatchlist = useCallback(() => {
    try {
      const details = getIndicatorDetails();
      const transformDetails = getTransformationDetails();
      
      if (!details) {
        throw new AppError(ERROR_TYPES.GENERAL_ERROR, "Invalid indicator selection");
      }
      
      const newItem = {
        id: `${selectedSource}-${selectedIndicator}-${Date.now()}`,
        source: selectedSource,
        indicator: selectedIndicator,
        name: details.name || selectedIndicator,
        transformation: selectedTransformation,
        transformationName: transformDetails.name || "Raw Data",
        startDate,
        endDate,
        frequency: details.frequency || 'monthly',
        dateAdded: new Date().toISOString(),
        metadata: {
          unit: details.unit || '',
          description: details.description || ''
        }
      };
      
      setWatchlist(prev => {
        // Check if already in watchlist
        const isDuplicate = prev.some(item => 
          item.source === newItem.source && 
          item.indicator === newItem.indicator &&
          item.transformation === newItem.transformation
        );
        
        if (isDuplicate) {
          setError(ERROR_MESSAGES.DUPLICATE_WATCHLIST);
          return prev;
        }
        
        return [...prev, newItem];
      });
    } catch (error) {
      setError(error instanceof AppError ? error.message : `Error adding to watchlist: ${error.message}`);
    }
  }, [selectedSource, selectedIndicator, selectedTransformation, startDate, endDate, getIndicatorDetails, getTransformationDetails, setWatchlist]);

  // Remove item from watchlist
  const removeFromWatchlist = useCallback((id) => {
    setWatchlist(prev => prev.filter(item => item.id !== id));
  }, [setWatchlist]);

  // Connect to WebSocket for live data
  useEffect(() => {
    if (selectedTab === 'live') {
      const unsubscribeStatus = WebSocketService.onConnectionStatusChange(setConnectionStatus);
      
      const unsubscribeMessage = WebSocketService.onMessage(data => {
        if (data && data.data) {
          setLiveData(prev => ({
            ...prev,
            ...data.data,
            lastUpdated: data.timestamp
          }));
        }
      });
      
      return () => {
        unsubscribeStatus();
        unsubscribeMessage();
      };
    }
  }, [selectedTab]);

  // WebSocket connection management
  const connectWebSocket = useCallback(() => {
    WebSocketService.connect();
  }, []);

  const disconnectWebSocket = useCallback(() => {
    WebSocketService.disconnect();
  }, []);

  // Memoized calculation of statistics to prevent unnecessary recalculations
  const statistics = useMemo(() => DataService.calculateStatistics(chartData), [chartData]);
  
  // Derived state for unit display
  const indicatorDetails = useMemo(() => getIndicatorDetails(), [getIndicatorDetails]);
  const transformationDetails = useMemo(() => getTransformationDetails(), [getTransformationDetails]);
  
  const isPercentageDisplay = useMemo(() => {
    return transformationDetails.resultUnit === 'percent' || 
           (indicatorDetails.unit && indicatorDetails.unit.toLowerCase().includes('percent'));
  }, [transformationDetails, indicatorDetails]);
  
  // Indicator unit for display
  const displayUnit = useMemo(() => {
    if (transformationDetails.resultUnit === 'percent') {
      return '%';
    }
    return indicatorDetails.unit || '';
  }, [transformationDetails, indicatorDetails]);

  return (
    <div className="min-h-screen bg-gray-100 p-4">
      <div className="max-w-6xl mx-auto">
        <header className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold text-gray-800">Financial Data Dashboard</h1>
          <div className="text-xs text-gray-500">
            {lastUpdated && (
              <p>Last updated: {lastUpdated.toLocaleString()}</p>
            )}
            <p>v{APP_VERSION}</p>
          </div>
        </header>

        {/* Error message display */}
        <ErrorMessage message={error} onDismiss={() => setError('')} />

        {/* Tabs */}
        <div className="mb-6">
          <div className="border-b border-gray-200">
            <nav className="flex -mb-px" role="tablist">
              <button
                onClick={() => setSelectedTab('explore')}
                className={`mr-4 py-2 px-4 font-medium text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                  selectedTab === 'explore'
                    ? 'border-b-2 border-blue-500 text-blue-600'
                    : 'text-gray-600 hover:text-gray-800'
                }`}
                role="tab"
                aria-selected={selectedTab === 'explore'}
                aria-controls="panel-explore"
                id="tab-explore"
              >
                Explore Data
              </button>
              <button
                onClick={() => setSelectedTab('watchlist')}
                className={`mr-4 py-2 px-4 font-medium text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                  selectedTab === 'watchlist'
                    ? 'border-b-2 border-blue-500 text-blue-600'
                    : 'text-gray-600 hover:text-gray-800'
                }`}
                role="tab"
                aria-selected={selectedTab === 'watchlist'}
                aria-controls="panel-watchlist"
                id="tab-watchlist"
              >
                Watchlist ({watchlist.length})
              </button>
              <button
                onClick={() => setSelectedTab('live')}
                className={`py-2 px-4 font-medium text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                  selectedTab === 'live'
                    ? 'border-b-2 border-blue-500 text-blue-600'
                    : 'text-gray-600 hover:text-gray-800'
                }`}
                role="tab"
                aria-selected={selectedTab === 'live'}
                aria-controls="panel-live"
                id="tab-live"
              >
                Live Data
              </button>
            </nav>
          </div>
        </div>

        {/* Explore Data Tab */}
        {selectedTab === 'explore' && (
          <div 
            className="bg-white shadow rounded-lg p-6"
            role="tabpanel"
            id="panel-explore"
            aria-labelledby="tab-explore"
          >
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
              {/* Data Source */}
              <div>
                <label 
                  className="block text-sm font-medium text-gray-700 mb-1"
                  htmlFor="data-source"
                >
                  Data Source
                </label>
                <select
                  id="data-source"
                  value={selectedSource}
                  onChange={(e) => {
                    setSelectedSource(e.target.value);
                    // Select first indicator from new source
                    const firstIndicator = DATA_SOURCES[e.target.value]?.[0]?.id || '';
                    setSelectedIndicator(firstIndicator);
                  }}
                  className="w-full p-2 border rounded bg-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  aria-describedby="transformation-help"
                >
                  {TRANSFORMATIONS.map(transform => (
                    <option key={transform.id} value={transform.id}>{transform.name}</option>
                  ))}
                </select>
                <p id="transformation-help" className="text-xs text-gray-400 mt-1">
                  {transformationDetails.description || "Apply mathematical transformation to data"}
                </p>
              </div>
            </div>

            <div className="flex flex-wrap gap-4 mb-6">
              {/* Date Range */}
              <div className="flex items-center gap-2">
                <div>
                  <label 
                    className="block text-sm font-medium text-gray-700 mb-1"
                    htmlFor="start-date"
                  >
                    Start Date
                  </label>
                  <input
                    id="start-date"
                    type="date"
                    value={startDate}
                    onChange={(e) => setStartDate(e.target.value)}
                    className="p-2 border rounded bg-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                    max={endDate}
                  />
                </div>
                <div>
                  <label 
                    className="block text-sm font-medium text-gray-700 mb-1"
                    htmlFor="end-date"
                  >
                    End Date
                  </label>
                  <input
                    id="end-date"
                    type="date"
                    value={endDate}
                    onChange={(e) => setEndDate(e.target.value)}
                    className="p-2 border rounded bg-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                    min={startDate}
                  />
                </div>
              </div>

              {/* Action Buttons */}
              <div className="flex items-end gap-2">
                <button
                  onClick={() => fetchData()}
                  className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition duration-150 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  disabled={isLoading}
                  aria-busy={isLoading}
                >
                  {isLoading ? 'Loading...' : 'Update Chart'}
                </button>

                <button
                  onClick={addToWatchlist}
                  className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition duration-150 focus:outline-none focus:ring-2 focus:ring-green-500"
                  disabled={isLoading}
                >
                  Add to Watchlist
                </button>
              </div>
            </div>

            {/* Chart */}
            <div className="h-96 mb-4" role="region" aria-live="polite">
              {isLoading ? (
                <LoadingIndicator message="Loading chart data..." />
              ) : chartData.length > 0 ? (
                <ResponsiveContainer width="100%" height="100%">
                  <LineChart
                    data={chartData}
                    margin={{ top: 20, right: 30, left: 20, bottom: 20 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
                    <XAxis
                      dataKey="date"
                      tick={{ fontSize: 12 }}
                      angle={-30}
                      textAnchor="end"
                      minTickGap={30}
                      padding={{ left: 10, right: 10 }}
                    />
                    <YAxis 
                      tick={{ fontSize: 12 }} 
                      domain={['auto', 'auto']} 
                      tickFormatter={(value) => isPercentageDisplay
                        ? `${value}%` 
                        : value.toLocaleString()
                      }
                      label={{ 
                        value: displayUnit, 
                        angle: -90, 
                        position: 'insideLeft',
                        style: { textAnchor: 'middle' }
                      }}
                    />
                    <Tooltip 
                      formatter={(value) => [
                        `${parseFloat(value).toFixed(2)}${isPercentageDisplay ? '%' : ''}`,
                        transformationDetails.name || "Value"
                      ]}
                      labelFormatter={(label) => new Date(label).toLocaleDateString()}
                    />
                    <Legend />
                    <Line
                      type="monotone"
                      dataKey="value"
                      name={indicatorDetails.name || selectedIndicator}
                      stroke="#3B82F6"
                      strokeWidth={2}
                      dot={{ r: 2 }}
                      activeDot={{ r: 6 }}
                      isAnimationActive={true}
                    />

                    {/* Crisis Markers */}
                    {FINANCIAL_CRISES.map(crisis => {
                      // Ensure crisis date is within the chart's visible range for ReferenceLine/Area
                      const crisisStartDate = crisis.date || crisis.startDate;
                      const crisisEndDate = crisis.date || crisis.endDate;
                      
                      if (!crisisStartDate || !parseDate(crisisStartDate) || 
                          (crisisEndDate && !parseDate(crisisEndDate))) {
                        return null; // Skip if dates are invalid
                      }
                      
                      if (parseDate(crisisStartDate) > parseDate(endDate) || 
                          parseDate(crisisEndDate || crisisStartDate) < parseDate(startDate)) {
                        return null; // Don't render if crisis is outside current date range
                      }

                      // Different styling based on severity
                      const severityColor = crisis.severity === "extreme" ? "rgba(220, 38, 38, 0.9)" : 
                                          crisis.severity === "high" ? "rgba(239, 68, 68, 0.7)" :
                                          "rgba(251, 113, 133, 0.7)";
                      
                      if (crisis.date) {
                        return (
                          <ReferenceLine
                            key={crisis.name}
                            x={crisis.date}
                            stroke={severityColor}
                            strokeDasharray="4 4"
                            ifOverflow="extendDomain"
                          >
                            <Label 
                              value={crisis.name} 
                              position="insideTopRight" 
                              fill={severityColor}
                              fontSize={10} 
                              angle={-45} 
                              dy={-5} 
                              dx={5}
                            />
                          </ReferenceLine>
                        );
                      } else if (crisis.startDate && crisis.endDate) {
                        return (
                          <ReferenceArea
                            key={crisis.name}
                            x1={crisis.startDate}
                            x2={crisis.endDate}
                            fill={`${severityColor.replace('0.7', '0.1')}`}
                            stroke={severityColor}
                            ifOverflow="extendDomain"
                          >
                            <Label 
                              value={crisis.name} 
                              position="insideTopRight" 
                              fill={severityColor}
                              fontSize={10} 
                              angle={-45} 
                              dy={-5} 
                              dx={5}
                            />
                          </ReferenceArea>
                        );
                      }
                      return null;
                    })}
                  </LineChart>
                </ResponsiveContainer>
              ) : (
                <EmptyState 
                  message="No data available. Try adjusting your filters or date range." 
                  action={() => fetchData()}
                  actionLabel="Retry"
                />
              )}
            </div>

            {/* Statistics */}
            {!isLoading && chartData.length > 0 && (
              <div className="bg-gray-50 p-4 rounded">
                <h3 className="text-lg font-semibold mb-2">
                  Statistics ({transformationDetails.name || "Raw"} data)
                </h3>
                <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                  <div>
                    <p className="text-sm text-gray-500">Min</p>
                    <p className="text-xl font-medium">
                      {formatValue(statistics.min, selectedTransformation)}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-gray-500">Max</p>
                    <p className="text-xl font-medium">
                      {formatValue(statistics.max, selectedTransformation)}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-gray-500">Average</p>
                    <p className="text-xl font-medium">
                      {formatValue(statistics.mean, selectedTransformation)}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-gray-500">Median</p>
                    <p className="text-xl font-medium">
                      {formatValue(statistics.median, selectedTransformation)}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-gray-500">Std Dev</p>
                    <p className="text-xl font-medium">
                      {formatValue(statistics.stdDev, selectedTransformation)}
                    </p>
                  </div>
                </div>

                {/* Indicator information */}
                {indicatorDetails.description && (
                  <div className="mt-4 border-t border-gray-200 pt-4">
                    <h4 className="text-sm font-medium text-gray-700 mb-1">About this indicator</h4>
                    <p className="text-sm text-gray-600">{indicatorDetails.description}</p>
                    {indicatorDetails.unit && (
                      <p className="text-sm text-gray-500 mt-1">Unit: {indicatorDetails.unit}</p>
                    )}
                  </div>
                )}
              </div>
            )}
          </div>
        )}

        {/* Watchlist Tab */}
        {selectedTab === 'watchlist' && (
          <div 
            className="bg-white shadow rounded-lg p-6"
            role="tabpanel"
            id="panel-watchlist"
            aria-labelledby="tab-watchlist"
          >
            <h2 className="text-xl font-semibold mb-4">Your Watchlist</h2>
            {watchlist.length === 0 ? (
              <EmptyState 
                message="Your watchlist is empty." 
                action={() => setSelectedTab('explore')}
                actionLabel="Go to Explore Tab to Add Indicators"
              />
            ) : (
              <>
                <div className="mb-4 flex justify-between items-center">
                  <p className="text-sm text-gray-500">
                    Showing {watchlist.length} {watchlist.length === 1 ? 'item' : 'items'}
                  </p>
                  <button
                    onClick={() => {
                      if (window.confirm("Are you sure you want to clear all items from your watchlist?")) {
                        setWatchlist([]);
                      }
                    }}
                    className="px-3 py-1 text-sm bg-red-100 text-red-700 rounded hover:bg-red-200 transition duration-150 focus:outline-none focus:ring-2 focus:ring-red-500"
                  >
                    Clear All
                  </button>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {watchlist.map(item => (
                    <div 
                      key={item.id} 
                      className="border rounded-lg p-4 hover:shadow-md transition-shadow duration-200"
                      aria-label={`Watchlist item: ${item.name}`}
                    >
                      <div className="flex justify-between items-start mb-2">
                        <div>
                          <h3 className="text-lg font-medium">{item.name}</h3>
                          <p className="text-sm text-gray-500">
                            {item.source} ({item.indicator}) - {item.transformationName || "Raw Data"}
                          </p>
                          <p className="text-xs text-gray-400">
                            Added: {new Date(item.dateAdded).toLocaleDateString()}
                          </p>
                          {item.metadata && item.metadata.unit && (
                            <p className="text-xs text-gray-400">Unit: {item.metadata.unit}</p>
                          )}
                        </div>
                        <button
                          onClick={() => removeFromWatchlist(item.id)}
                          className="text-red-500 hover:text-red-700 text-sm transition-colors duration-150 focus:outline-none focus:ring-2 focus:ring-red-500 rounded"
                          aria-label={`Remove ${item.name} from watchlist`}
                        >
                          Remove
                        </button>
                      </div>
                      <WatchlistItemChart item={item} />
                    </div>
                  ))}
                </div>
              </>
            )}
          </div>
        )}

        {/* Live Data Tab */}
        {selectedTab === 'live' && (
          <div 
            className="bg-white shadow rounded-lg p-6"
            role="tabpanel"
            id="panel-live"
            aria-labelledby="tab-live"
          >
            <h2 className="text-xl font-semibold mb-4">Live Data Feed</h2>
            <div className="mb-6">
              <div className="flex items-center gap-4 mb-4">
                <p className="text-sm font-medium">
                  Status: <span className={`font-semibold ${connectionStatus === 'Connected' ? 'text-green-600' : 'text-red-600'}`}>{connectionStatus}</span>
                </p>
                {connectionStatus !== 'Connected' ? (
                  <button
                    onClick={connectWebSocket}
                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm transition duration-150 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    Connect to WebSocket
                  </button>
                ) : (
                  <button
                    onClick={disconnectWebSocket}
                    className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 text-sm transition duration-150 focus:outline-none focus:ring-2 focus:ring-red-500"
                  >
                    Disconnect
                  </button>
                )}
              </div>
              
              {/* Live data display */}
              {connectionStatus === 'Connected' && Object.keys(liveData).length > 0 && (
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                  {Object.entries(liveData)
                    .filter(([key]) => key !== 'lastUpdated')
                    .map(([key, data]) => {
                      if (!data) return null;
                      const indicator = Object.values(DATA_SOURCES)
                        .flat()
                        .find(ind => ind.id === key);
                      
                      const name = indicator?.name || key;
                      const unit = indicator?.unit || '';
                      
                      return (
                        <div key={key} className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                          <div className="flex justify-between mb-2">
                            <h3 className="font-medium">{name}</h3>
                            <span 
                              className={`text-xs px-2 py-1 rounded-full ${
                                parseFloat(data.change) >= 0 
                                  ? 'bg-green-100 text-green-800' 
                                  : 'bg-red-100 text-red-800'
                              }`}
                            >
                              {parseFloat(data.change) >= 0 ? '+' : ''}{data.change}
                            </span>
                          </div>
                          <p className="text-2xl font-bold">
                            {data.value}{unit.includes('Percent') ? '%' : ''}
                          </p>
                          <p className="text-xs text-gray-500 mt-2">
                            Refreshes automatically
                          </p>
                        </div>
                      );
                    })}
                </div>
              )}
              
              {connectionStatus === 'Connected' && Object.keys(liveData).length === 0 && (
                <div className="text-center p-6 bg-gray-50 rounded-lg">
                  <p className="text-gray-500">Waiting for data updates...</p>
                </div>
              )}
              
              {connectionStatus !== 'Connected' && (
                <div className="text-center p-6 bg-gray-50 rounded-lg">
                  <p className="text-gray-500">Connect to WebSocket to receive live updates</p>
                </div>
              )}
              
              <div className="p-4 bg-gray-50 rounded mt-6">
                <h3 className="text-lg font-medium mb-2">Fault-Tolerant WebSocket Implementation</h3>
                <p className="text-sm text-gray-600 mb-4">
                  This implementation demonstrates a production-grade fault-tolerant WebSocket connection with automatic 
                  reconnection and partial data handling. If any data source fails, the system continues to display 
                  available data while attempting recovery.
                </p>
                <div className="bg-gray-800 text-gray-200 p-3 rounded font-mono text-xs overflow-x-auto">
                  <pre>{`// Fault-tolerant WebSocket client implementation
class WebSocketClient {
  constructor(url, options = {}) {
    this.url = url;
    this.options = {
      reconnectInterval: 2000,
      reconnectAttempts: 10,
      connectionTimeout: 5000,
      heartbeatInterval: 30000,
      ...options
    };
    
    this.reconnectCount = 0;
    this.lastHeartbeat = null;
    this.heartbeatTimer = null;
    this.connectionTimer = null;
    
    this.handlers = {
      message: new Set(),
      open: new Set(),
      close: new Set(),
      error: new Set()
    };
    
    this.sourceStatus = new Map(); // Track individual data source status
    
    this.connect();
  }
  
  connect() {
    // Clear existing timers
    if (this.connectionTimer) clearTimeout(this.connectionTimer);
    if (this.heartbeatTimer) clearTimeout(this.heartbeatTimer);
    
    try {
      this.socket = new WebSocket(this.url);
      
      // Set connection timeout
      this.connectionTimer = setTimeout(() => {
        if (this.socket.readyState !== WebSocket.OPEN) {
          console.error(\`[WebSocket] Connection timeout after \${this.options.connectionTimeout}ms\`);
          this.socket.close();
        }
      }, this.options.connectionTimeout);
      
      this.socket.onopen = (event) => {
        console.log(\`[WebSocket] Connected to \${this.url}\`);
        clearTimeout(this.connectionTimer);
        this.reconnectCount = 0;
        this.lastHeartbeat = Date.now();
        
        // Start heartbeat monitoring
        this.startHeartbeatMonitoring();
        
        // Subscribe to data feeds
        this.send({
          action: 'subscribe',
          sources: ['UNRATE', 'GDP', 'FEDFUNDS', 'FSI'],
          timestamp: new Date().toISOString()
        });
        
        // Trigger all open handlers
        this.handlers.open.forEach(handler => handler({
          type: 'open',
          timestamp: new Date().toISOString()
        }));
      };
      
      this.socket.onmessage = (event) => {
        try {
          let data = JSON.parse(event.data);
          
          // Detect and handle heartbeat messages
          if (data.type === 'heartbeat') {
            this.lastHeartbeat = Date.now();
            return;
          }
          
          // Handle individual source errors
          if (data.errors && Array.isArray(data.errors)) {
            data.errors.forEach(error => {
              if (error.source) {
                console.warn(\`[WebSocket] Error with source \${error.source}: \${error.message}\`);
                this.sourceStatus.set(error.source, {
                  status: 'error',
                  message: error.message,
                  timestamp: new Date().toISOString()
                });
              }
            });
          }
          
          // Update source status for successful data
          if (data.data) {
            Object.keys(data.data).forEach(source => {
              this.sourceStatus.set(source, {
                status: 'ok',
                timestamp: new Date().toISOString()
              });
            });
          }
          
          // Trigger all message handlers with data and source status
          this.handlers.message.forEach(handler => handler({
            ...data,
            _meta: {
              sourceStatus: Object.fromEntries(this.sourceStatus)
            }
          }));
        } catch (error) {
          console.error('[WebSocket] Error parsing message:', error);
        }
      };
      
      this.socket.onclose = (event) => {
        clearTimeout(this.connectionTimer);
        clearInterval(this.heartbeatTimer);
        
        console.log(\`[WebSocket] Connection closed: \${event.code} \${event.reason}\`);
        
        // Trigger all close handlers
        this.handlers.close.forEach(handler => handler({
          type: 'close',
          code: event.code,
          reason: event.reason,
          timestamp: new Date().toISOString()
        }));
        
        // Attempt reconnection if not explicitly closed and not max attempts
        if (event.code !== 1000 && this.reconnectCount < this.options.reconnectAttempts) {
          this.attemptReconnect();
        }
      };
      
      this.socket.onerror = (error) => {
        console.error('[WebSocket] Error:', error);
        
        // Trigger all error handlers
        this.handlers.error.forEach(handler => handler({
          type: 'error',
          error: error,
          timestamp: new Date().toISOString()
        }));
      };
    } catch (error) {
      console.error('[WebSocket] Setup error:', error);
      this.attemptReconnect();
    }
  }
  
  startHeartbeatMonitoring() {
    this.heartbeatTimer = setInterval(() => {
      const now = Date.now();
      if (now - this.lastHeartbeat > this.options.heartbeatInterval * 1.5) {
        console.warn('[WebSocket] No heartbeat received, connection may be stale');
        this.socket.close(4000, 'Heartbeat timeout');
      } else {
        // Send heartbeat request
        this.send({ type: 'heartbeat' });
      }
    }, this.options.heartbeatInterval);
  }
  
  attemptReconnect() {
    this.reconnectCount++;
    console.log(\`[WebSocket] Attempting reconnection \${this.reconnectCount} of \${this.options.reconnectAttempts}\`);
    
    // Notify handlers about reconnection attempt
    this.handlers.close.forEach(handler => handler({
      type: 'reconnecting',
      attempt: this.reconnectCount,
      maxAttempts: this.options.reconnectAttempts,
      timestamp: new Date().toISOString()
    }));
    
    // Exponential backoff
    const delay = this.options.reconnectInterval * Math.pow(1.5, this.reconnectCount - 1);
    setTimeout(() => this.connect(), delay);
  }
  
  send(data) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      try {
        this.socket.send(JSON.stringify(data));
      } catch (error) {
        console.error('[WebSocket] Error sending message:', error);
      }
    } else {
      console.warn('[WebSocket] Cannot send message, connection not open');
    }
  }
  
  onMessage(handler) {
    this.handlers.message.add(handler);
    return () => this.handlers.message.delete(handler);
  }
  
  onOpen(handler) {
    this.handlers.open.add(handler);
    return () => this.handlers.open.delete(handler);
  }
  
  onClose(handler) {
    this.handlers.close.add(handler);
    return () => this.handlers.close.delete(handler);
  }
  
  onError(handler) {
    this.handlers.error.add(handler);
    return () => this.handlers.error.delete(handler);
  }
  
  getSourceStatus() {
    return Object.fromEntries(this.sourceStatus);
  }
  
  disconnect() {
    if (this.socket) {
      this.socket.close(1000, 'Normal closure');
    }
    
    if (this.connectionTimer) {
      clearTimeout(this.connectionTimer);
    }
    
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
    }
  }
}`}</pre>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Footer */}
        <footer className="mt-8 text-center text-xs text-gray-500">
          <p>Financial Data Dashboard v{APP_VERSION} - Enterprise Edition</p>
          <p className="mt-1">
            This application demonstrates robust financial data visualization with fault tolerance.
            Built with industry best practices for maximum reliability.
          </p>
          <p className="mt-1">
            Â© {new Date().getFullYear()} Your Company - All Rights Reserved
          </p>
        </footer>
      </div>
    </div>
  );
};

export default Dashboard; focus:border-blue-500"
                  aria-describedby="data-source-help"
                >
                  {Object.keys(DATA_SOURCES).map(source => (
                    <option key={source} value={source}>{source}</option>
                  ))}
                </select>
                <p id="data-source-help" className="text-xs text-gray-400 mt-1">
                  Select the data provider
                </p>
              </div>

              {/* Indicator */}
              <div>
                <label 
                  className="block text-sm font-medium text-gray-700 mb-1"
                  htmlFor="indicator"
                >
                  Indicator
                </label>
                <select
                  id="indicator"
                  value={selectedIndicator}
                  onChange={(e) => setSelectedIndicator(e.target.value)}
                  className="w-full p-2 border rounded bg-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  aria-describedby="indicator-help"
                >
                  {(DATA_SOURCES[selectedSource] || []).map(indicator => (
                    <option key={indicator.id} value={indicator.id}>{indicator.name}</option>
                  ))}
                </select>
                <p id="indicator-help" className="text-xs text-gray-400 mt-1">
                  {indicatorDetails.description || "Select the economic indicator to display"}
                </p>
              </div>

              {/* Time Frame */}
              <div>
                <label 
                  className="block text-sm font-medium text-gray-700 mb-1"
                  htmlFor="time-frame"
                >
                  Time Frame
                </label>
                <select
                  id="time-frame"
                  value={selectedTimeFrame}
                  onChange={(e) => setSelectedTimeFrame(e.target.value)}
                  className="w-full p-2 border rounded bg-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  aria-describedby="time-frame-help"
                >
                  {TIME_FRAMES.map(frame => (
                    <option key={frame.id} value={frame.id}>{frame.name}</option>
                  ))}
                </select>
                <p id="time-frame-help" className="text-xs text-gray-400 mt-1">
                  {indicatorDetails.frequency 
                    ? `Native frequency: ${indicatorDetails.frequency}` 
                    : "Native frequency used for data generation"}
                </p>
              </div>

              {/* Transformation */}
              <div>
                <label 
                  className="block text-sm font-medium text-gray-700 mb-1"
                  htmlFor="transformation"
                >
                  Transformation
                </label>
                <select
                  id="transformation"
                  value={selectedTransformation}
                  onChange={(e) => setSelectedTransformation(e.target.value)}
                  className="w-full p-2 border rounded bg-white focus:ring-2 focus:ring-blue-500